<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: on | 小子的博客]]></title>
  <link href="http://yinsigan.github.io/blog/categories/on/atom.xml" rel="self"/>
  <link href="http://yinsigan.github.io/"/>
  <updated>2013-12-03T18:25:42+08:00</updated>
  <id>http://yinsigan.github.io/</id>
  <author>
    <name><![CDATA[小子]]></name>
    <email><![CDATA[ganweiliang886@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[acts_as_follower源码分析]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/03/acts-as-followeryuan-ma-fen-xi/"/>
    <updated>2013-12-03T16:41:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/03/acts-as-followeryuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<ul>
<li><a href="https://github.com/tcocca/acts_as_follower">acts_as_follower</a></li>
</ul>


<h3>这个gem是做什么的?</h3>

<p>这个gem主要是用来实现类似twitter那种关注，新浪那种收听的功能
主要是两个model的关联,例如一个用户订阅了一本书,我们可以这样实现<code>User.first.follow(Book.first)</code></p>

<hr />

<h3>来看一下它的数据结构</h3>

<p>目录树结构</p>

<p><img src="/images/acts_as_follower_file_tree.png"></p>

<p>结构库表结构</p>

<p><img src="/images/acts_as_follower_table_tree.png"></p>

<p>主要有五个字段,分别是<strong>blocked</strong>, <strong>followable_id</strong>, <strong>followable_type</strong>, <strong>follower_id</strong>, <strong>follower_type</strong>, 主要是分为两个多态(<strong>follower</strong>, <strong>followerable</strong>), 例如一个用户订阅了一本书, <strong>followerable</strong>可以存<strong>Book</strong>和它的<strong>id</strong>, 而<strong>follower</strong>这个多态存<strong>User</strong>和它的<strong>id</strong></p>

<hr />

<h3>接下来就来分晰啦</h3>

<h4>源码目录结构功能介绍</h4>

<ul>
<li>lib/acts_as_follower.rb: 主文件,主要定义了ActsAsFollower这个model(每个gem都会做差不多的事),还包括一些autoload语句，做的事主要是require你的所用到的rb文件啦</li>
</ul>


<p>``` ruby lib/acts_as_follower
require &ldquo;acts_as_follower/version&rdquo;</p>

<p>module ActsAsFollower
  autoload :Follower,     &lsquo;acts_as_follower/follower&rsquo;
  autoload :Followable,   &lsquo;acts_as_follower/followable&rsquo;
  autoload :FollowerLib,  &lsquo;acts_as_follower/follower_lib&rsquo;
  autoload :FollowScopes, &lsquo;acts_as_follower/follow_scopes&rsquo;</p>

<p>  require &lsquo;acts_as_follower/railtie&rsquo; if defined?(Rails) &amp;&amp; Rails::VERSION::MAJOR >= 3
end
```</p>

<ul>
<li>lib/acts_as_follower/railtie.rb: 这个文件的作用就大了,在model(继承自<strong>ActiveRecord::Base</strong>)能使用<strong>acts_as_followable</strong>,<strong>acts_as_follower</strong>这个多亏了这个文件,其实这个文件使用了一个叫railtie的rails部件,它官方的定义是这样的:<strong>Railtie is the core of the Rails framework and provides several hooks to extend Rails and/or modify the initialization process</strong>, 它能修改一些启动信息,在加载ActiveRecord部件时执行<code>include ActsAsFollower::Follower</code>这样的语句,以后每个继承自ActiveRecord::Base的class都能使用ActsAsFollower::Follower下面定义的方法(而acts_as_follower就是在这个文件里定义的)，其实可以用类似这样的写法<code>ActiveRecord::Base.send(:include, Juixe::Acts::Commentable)</code>来实现相同的目的,关于rails railtie的详细信息可查看<a href="http://api.rubyonrails.org/classes/Rails/Railtie.html">rails railtie</a>和<a href="http://ihower.tw/blog/archives/4873">Rails3: Railtie 和 Plugins 系統</a></li>
</ul>


<p>``` ruby lib/acts_as_follower/railtie.rb
require &lsquo;acts_as_follower&rsquo;
require &lsquo;rails&rsquo;</p>

<p>module ActsAsFollower
  class Railtie &lt; Rails::Railtie</p>

<pre><code>initializer "acts_as_follower.active_record" do |app|
  ActiveSupport.on_load :active_record do
    include ActsAsFollower::Follower
    include ActsAsFollower::Followable
  end
end
</code></pre>

<p>  end
end
```</p>

<ul>
<li>lib/acts_as_follower/followable.rb: 这个文件主要服务于被follow的对象,它定义了好多用于被<strong>follow</strong>的实例方法,包括<strong>followers_by_type</strong>, <strong>followers_count</strong>,它是这样来调用的,例如<code>Book.first.followers_count</code>, <code>Book.first.followers_by_type('User')</code></li>
</ul>


<p>``` ruby lib/acts_as_follower/followable.rb
module ActsAsFollower #:nodoc:</p>

<p>  # 由上面可知ActiveRecord会include下面的Followable
  module Followable</p>

<pre><code># 这种写法很常见
def self.included(base)
  base.extend ClassMethods
end

# ClassMethods下面定义的是实例方法,ActiveRecord::Base可直接用，也就是说可以直接在继承自ActiveRecord::Base的model下用
module ClassMethods
  def acts_as_followable
    has_many :followings, :as =&gt; :followable, :dependent =&gt; :destroy, :class_name =&gt; 'Follow'
    # 下面的实例方法
    include ActsAsFollower::Followable::InstanceMethods
    # 这个下文有说
    include ActsAsFollower::FollowerLib
  end
end

# 下面的都是实例方法可用于被follow的实例来调用
module InstanceMethods

  # Returns the number of followers a record has.
  # 返回followins的数量,而unblocked在lib/acts_as_followable/follow_scope.rb定义,只是一个简单的where scope
  def followers_count
    self.followings.unblocked.count
  end

  # Returns the followers by a given type
  def followers_by_type(follower_type, options={})
    follows = follower_type.constantize.
      joins(:follows).
      where('follows.blocked'         =&gt; false,
            'follows.followable_id'   =&gt; self.id,
            'follows.followable_type' =&gt; parent_class_name(self),
            'follows.follower_type'   =&gt; follower_type)
    if options.has_key?(:limit)
      follows = follows.limit(options[:limit])
    end
    if options.has_key?(:includes)
      follows = follows.includes(options[:includes])
    end
    follows
  end

  def followers_by_type_count(follower_type)
    self.followings.unblocked.for_follower_type(follower_type).count
  end

  # Allows magic names on followers_by_type
  # e.g. user_followers == followers_by_type('User')
  # Allows magic names on followers_by_type_count
  # e.g. count_user_followers == followers_by_type_count('User')
  def method_missing(m, *args)
    if m.to_s[/count_(.+)_followers/]
      followers_by_type_count($1.singularize.classify)
    elsif m.to_s[/(.+)_followers/]
      followers_by_type($1.singularize.classify)
    else
      super
    end
  end

  def blocked_followers_count
    self.followings.blocked.count
  end

  # Returns the followings records scoped
  def followers_scoped
    self.followings.includes(:follower)
  end

  def followers(options={})
    followers_scope = followers_scoped.unblocked
    followers_scope = apply_options_to_scope(followers_scope, options)
    followers_scope.to_a.collect{|f| f.follower}
  end

  def blocks(options={})
    blocked_followers_scope = followers_scoped.blocked
    blocked_followers_scope = apply_options_to_scope(blocked_followers_scope, options)
    blocked_followers_scope.to_a.collect{|f| f.follower}
  end

  # Returns true if the current instance is followed by the passed record
  # Returns false if the current instance is blocked by the passed record or no follow is found
  def followed_by?(follower)
    self.followings.unblocked.for_follower(follower).first.present?
  end

  def block(follower)
    get_follow_for(follower) ? block_existing_follow(follower) : block_future_follow(follower)
  end

  def unblock(follower)
    get_follow_for(follower).try(:delete)
  end

  def get_follow_for(follower)
    self.followings.for_follower(follower).first
  end

  private

  def block_future_follow(follower)
    Follow.create(:followable =&gt; self, :follower =&gt; follower, :blocked =&gt; true)
  end

  def block_existing_follow(follower)
    get_follow_for(follower).block!
  end

end
</code></pre>

<p>  end
end</p>

<p>```
+ lib/acts_as_follower/follower.rb</p>

<p>``` ruby lib/acts_as_follower/follower.rb
module ActsAsFollower #:nodoc:
  module Follower</p>

<pre><code>def self.included(base)
  base.extend ClassMethods
end

module ClassMethods
  def acts_as_follower
    has_many :follows, :as =&gt; :follower, :dependent =&gt; :destroy
    include ActsAsFollower::Follower::InstanceMethods
    include ActsAsFollower::FollowerLib
  end
end

module InstanceMethods

  # Returns true if this instance is following the object passed as an argument.
  def following?(followable)
    0 &lt; Follow.unblocked.for_follower(self).for_followable(followable).count
  end

  # Returns the number of objects this instance is following.
  def follow_count
    Follow.unblocked.for_follower(self).count
  end

  # Creates a new follow record for this instance to follow the passed object.
  # Does not allow duplicate records to be created.
  def follow(followable)
    if self != followable
      self.follows.find_or_create_by(followable_id: followable.id, followable_type: parent_class_name(followable))
    end
  end

  # Deletes the follow record if it exists.
  def stop_following(followable)
    if follow = get_follow(followable)
      follow.destroy
    end
  end

  # returns the follows records to the current instance
  def follows_scoped
    self.follows.unblocked.includes(:followable)
  end

  # Returns the follow records related to this instance by type.
  def follows_by_type(followable_type, options={})
    follows_scope  = follows_scoped.for_followable_type(followable_type)
    follows_scope = apply_options_to_scope(follows_scope, options)
  end

  # Returns the follow records related to this instance with the followable included.
  def all_follows(options={})
    follows_scope = follows_scoped
    follows_scope = apply_options_to_scope(follows_scope, options)
  end

  # Returns the actual records which this instance is following.
  def all_following(options={})
    all_follows(options).collect{ |f| f.followable }
  end

  # Returns the actual records of a particular type which this record is following.
  def following_by_type(followable_type, options={})
    followables = followable_type.constantize.
      joins(:followings).
      where('follows.blocked'         =&gt; false,
            'follows.follower_id'     =&gt; self.id,
            'follows.follower_type'   =&gt; parent_class_name(self),
            'follows.followable_type' =&gt; followable_type)
    if options.has_key?(:limit)
      followables = followables.limit(options[:limit])
    end
    if options.has_key?(:includes)
      followables = followables.includes(options[:includes])
    end
    followables
  end

  def following_by_type_count(followable_type)
    follows.unblocked.for_followable_type(followable_type).count
  end

  # Allows magic names on following_by_type
  # e.g. following_users == following_by_type('User')
  # Allows magic names on following_by_type_count
  # e.g. following_users_count == following_by_type_count('User')
  def method_missing(m, *args)
    if m.to_s[/following_(.+)_count/]
      following_by_type_count($1.singularize.classify)
    elsif m.to_s[/following_(.+)/]
      following_by_type($1.singularize.classify)
    else
      super
    end
  end

  # Returns a follow record for the current instance and followable object.
  def get_follow(followable)
    self.follows.unblocked.for_followable(followable).first
  end

end
</code></pre>

<p>  end
end</p>

<p>```
+ lib/acts_as_follower/follow_scopes.rb</p>

<p>``` ruby lib/acts_as_follower/follow_scopes.rb
module ActsAsFollower #:nodoc:
  module FollowScopes</p>

<pre><code>def for_follower(follower)
  where(:follower_id =&gt; follower.id,
        :follower_type =&gt; parent_class_name(follower))
end

def for_followable(followable)
  where(:followable_id =&gt; followable.id, :followable_type =&gt; parent_class_name(followable))
end

def for_follower_type(follower_type)
  where(:follower_type =&gt; follower_type)
end

def for_followable_type(followable_type)
  where(:followable_type =&gt; followable_type)
end

def recent(from)
  where(["created_at &gt; ?", (from || 2.weeks.ago).to_s(:db)])
end

def descending
  order("follows.created_at DESC")
end

def unblocked
  where(:blocked =&gt; false)
end

def blocked
  where(:blocked =&gt; true)
end
</code></pre>

<p>  end
end
```</p>

<ul>
<li>lib/acts_as_follower/follower_lib.rb:</li>
</ul>


<p>``` ruby lib/acts_as_follower/follower_lib.rb
module ActsAsFollower
  module FollowerLib</p>

<pre><code>private

# Retrieves the parent class name if using STI.
def parent_class_name(obj)
  if obj.class.superclass != ActiveRecord::Base
    return obj.class.superclass.name
  end
  return obj.class.name
end

def apply_options_to_scope(scope, options = {})
  if options.has_key?(:limit)
    scope = scope.limit(options[:limit])
  end
  if options.has_key?(:includes)
    scope = scope.includes(options[:includes])
  end
  if options.has_key?(:joins)
    scope = scope.joins(options[:joins])
  end
  if options.has_key?(:where)
    scope = scope.order(options[:where])
  end
  if options.has_key?(:order)
    scope = scope.order(options[:order])
  end
  scope
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<ul>
<li>lib/acts_as_follower/generators/templates/follow.rb</li>
</ul>


<p>``` ruby app/models/follow.rb
class Follow &lt; ActiveRecord::Base</p>

<p>  extend ActsAsFollower::FollowerLib
  extend ActsAsFollower::FollowScopes</p>

<p>  # NOTE: Follows belong to the &ldquo;followable&rdquo; interface, and also to followers
  belongs_to :followable, :polymorphic => true
  belongs_to :follower,   :polymorphic => true</p>

<p>  def block!</p>

<pre><code>self.update_attribute(:blocked, true)
</code></pre>

<p>  end</p>

<p>end
```</p>

<h3>总结</h3>

<p>学会组织代码的能力和一些rails的内部的东西</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Acts As Commentable source analyse]]></title>
    <link href="http://yinsigan.github.io/blog/2013/11/26/acts-as-commentable-source-analyse/"/>
    <updated>2013-11-26T11:49:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/11/26/acts-as-commentable-source-analyse</id>
    <content type="html"><![CDATA[<ul>
<li><a href="https://github.com/jackdempsey/acts_as_commentable">acts_as_commentable</a></li>
</ul>


<h3>安装</h3>

<p><code>rails g comment</code></p>

<h4>分析</h4>

<p>源码目录下如下</p>

<p><img src="/images/acts_as_commentable_file_tree.png"></p>

<p>这一步会生成一个rails migration文件和一个叫comment.rb的rails model文件</p>

<p>原理很简单,会在数据库中生成一个叫comments的表
它的字段包括title, comment, commentable_type, commentable_id, user_id等</p>

<p>而生成这两个模版文件的源码如下:</p>

<p>``` ruby lib/generators/comment/comment_generator.rb
require &lsquo;rails/generators/migration&rsquo;</p>

<p>class CommentGenerator &lt; Rails::Generators::Base
  include Rails::Generators::Migration</p>

<p>  def self.source_root</p>

<pre><code>@_acts_as_commentable_source_root ||= File.expand_path("../templates", __FILE__)
</code></pre>

<p>  end</p>

<p>  def self.next_migration_number(path)</p>

<pre><code>Time.now.utc.strftime("%Y%m%d%H%M%S")
</code></pre>

<p>  end</p>

<p>  def create_model_file</p>

<pre><code>template "comment.rb", "app/models/comment.rb"
migration_template "create_comments.rb", "db/migrate/create_comments.rb"
</code></pre>

<p>  end
end
```</p>

<p>这是使用rails generation功能实现的</p>

<!-- more -->


<p>还可以查看其他gem的实现方式</p>

<p><a href="https://github.com/LTe/acts-as-messageable/blob/master/lib/generators/acts-as-messageable/migration/migration_generator.rb">acts_as_messageable</a></p>

<p>更详细的可参考<a href="http://guides.rubyonrails.org/generators.html">rails generation</a></p>

<h3>如何使用</h3>

<p>``` ruby
class Post &lt; ActiveRecord::Base
  acts_as_commentable
end</p>

<p>commentable = Post.create
commentable.comments.create(:title => &ldquo;First comment.&rdquo;, :comment => &ldquo;This is the first comment.&rdquo;)
```</p>

<h4>分析</h4>

<p>如果不使用gem来写评论，一般我们会在model上写has_many comments这样的东西，而acts_as_commentable这个gem它也是要实现这个的，只是它进行包装</p>

<p>关键在<code>acts_as_commentable</code>这一行</p>

<p>``` ruby lib/commentable_method.rb
require &lsquo;active_record&rsquo;</p>

<h1>ActsAsCommentable</h1>

<p>module Juixe
  module Acts #:nodoc:</p>

<pre><code>module Commentable #:nodoc:

  def self.included(base)
    base.extend ClassMethods  
  end

  module ClassMethods
    def acts_as_commentable(options={})
      has_many :comments, {:as =&gt; :commentable, :dependent =&gt; :destroy}.merge(options)
      include Juixe::Acts::Commentable::InstanceMethods
      extend Juixe::Acts::Commentable::SingletonMethods
    end
  end
  ...
</code></pre>

<p>ActiveRecord::Base.send(:include, Juixe::Acts::Commentable)
```</p>

<p>有这一句<code>ActiveRecord::Base.send(:include, Juixe::Acts::Commentable)</code>只要任何继承ActiveRecord::Base的model都可以使用<code>acts_as_commentable</code> 它是一个classMethods</p>

<p>现在我们来分析源码commentable_methods.rb</p>

<p><code>ruby
has_many :comments, {:as =&gt; :commentable, :dependent =&gt; :destroy}.merge(options)
include Juixe::Acts::Commentable::InstanceMethods
extend Juixe::Acts::Commentable::SingletonMethods
</code></p>

<p>第一行是一个activemodel relationship表示model使用多态的comment
<code>Juixe::Acts::Commentable::SingletonMethods</code>是类的单例方法,下面的方法可以用Post.find_comments_by_user来调用,例如
Book.find_comments_for(Book.last)</p>

<p>``` ruby</p>

<h1>This module contains class methods</h1>

<p>module SingletonMethods
  # Helper method to lookup for comments for a given object.
  # This method is equivalent to obj.comments.
  def find_comments_for(obj)</p>

<pre><code>commentable = self.base_class.name
Comment.find_comments_for_commentable(commentable, obj.id)
</code></pre>

<p>  end</p>

<p>  # Helper class method to lookup comments for
  # the mixin commentable type written by a given user.<br/>
  # This method is NOT equivalent to Comment.find_comments_for_user
  def find_comments_by_user(user)</p>

<pre><code>commentable = self.base_class.name
Comment.where(["user_id = ? and commentable_type = ?", user.id, commentable]).order("created_at DESC")
</code></pre>

<p>  end
end
```</p>

<p>Juixe::Acts::Commentable::InstanceMethods是实例方法
可以通过类似这样的方式来调用实例方法
<code>Book.last.add_comment Comment.create(comment: "second comment")</code></p>

<p>接下来我们来看看comment.rb这边</p>

<p>它总要来个belongs_to吧</p>

<p>``` ruby comment.rb
class Comment &lt; ActiveRecord::Base</p>

<p>  include ActsAsCommentable::Comment</p>

<p>  belongs_to :commentable, :polymorphic => true</p>

<p>  default_scope :order => &lsquo;created_at ASC&rsquo;</p>

<p>  # NOTE: install the acts_as_votable plugin if you
  # want user to vote on the quality of comments.
  #acts_as_voteable</p>

<p>  # NOTE: Comments belong to a user
  belongs_to :user
end
```</p>

<p><code>belongs_to :commentable, :polymorphic =&gt; true</code>这就是原理
然而<code>include ActsAsCommentable::Comment</code>这个会做什么呢</p>

<p>接上来往下看</p>

<p>``` ruby lib/comment_method.rb
module ActsAsCommentable
  # including this module into your Comment model will give you finders and named scopes
  # useful for working with Comments.
  # The named scopes are:
  #   in_order: Returns comments in the order they were created (created_at ASC).
  #   recent: Returns comments by how recently they were created (created_at DESC).
  #   limit(N): Return no more than N comments.
  module Comment</p>

<pre><code>def self.included(comment_model)
  comment_model.extend Finders
  comment_model.scope :in_order, comment_model.order('created_at ASC')
  comment_model.scope :recent,   comment_model.order('created_at DESC')
end

module Finders
  # Helper class method to lookup all comments assigned
  # to all commentable types for a given user.
  def find_comments_by_user(user)
    where(["user_id = ?", user.id]).order("created_at DESC")
  end

  # Helper class method to look up all comments for 
  # commentable class name and commentable id.
  def find_comments_for_commentable(commentable_str, commentable_id)
    where(["commentable_type = ? and commentable_id = ?", commentable_str, commentable_id]).order("created_at DESC")
  end

  # Helper class method to look up a commentable object
  # given the commentable class name and id 
  def find_commentable(commentable_str, commentable_id)
    model = commentable_str.constantize
    model.respond_to?(:find_comments_for) ? model.find(commentable_id) : nil
  end
end
</code></pre>

<p>  end
end
```</p>

<p>可以用Comment.find_comments_by_user的方式来调用</p>

<h3>总结</h3>

<p>它的源码并不复杂，我们通过它并不是要写出跟它一样或类似的gem来，只是可以让我们明白一个道理,代码的重用与组织, 就像在Post.rb里写上acts_as_commentable就可以创建评论了,很方便,还有,通过学习这个gem我们可以学习它是如何设计数据库的</p>

<p>类似的gem还有</p>

<ul>
<li><a href="https://github.com/tcocca/acts_as_follower">acts_as_follower</a></li>
<li><a href="https://github.com/LTe/acts-as-messageable">acts-as-messageable</a></li>
<li><a href="https://github.com/mbleigh/acts-as-taggable-on">acts-as-taggable-on</a></li>
<li><a href="https://github.com/goncalossilva/acts_as_paranoid">acts_as_paranoid</a></li>
<li><a href="https://github.com/stefankroes/ancestry">ancestry</a></li>
<li><a href="https://github.com/collectiveidea/awesome_nested_set">awesome_nested_set</a></li>
</ul>


<p>关于acts_as_commentable更详细的用法可查看
<a href="http://juixe.com/techknow/index.php/2006/06/18/acts-as-commentable-plugin/">acts-as-commentable-plugin</a></p>
]]></content>
  </entry>
  
</feed>
