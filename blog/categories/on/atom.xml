<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: on | 小子的博客]]></title>
  <link href="http://yinsigan.github.io/blog/categories/on/atom.xml" rel="self"/>
  <link href="http://yinsigan.github.io/"/>
  <updated>2013-12-12T11:15:20+08:00</updated>
  <id>http://yinsigan.github.io/</id>
  <author>
    <name><![CDATA[小子]]></name>
    <email><![CDATA[ganweiliang886@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Association Reference]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/11/rails-association-reference/"/>
    <updated>2013-12-11T10:09:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/11/rails-association-reference</id>
    <content type="html"><![CDATA[<h2>rails关联模型参数的使用</h2>

<p>上一篇<a href="http://yinsigan.github.io/blog/2013/12/10/rails-association/">rails association</a>说明了rails的各种模型的原理和设计,这篇我们来说说rails association具体参数的使用,通过一些案例或代码来分析它们的使用场景</p>

<p><img src="/images/rails_association_reference/has_many_through.png"></p>

<p>``` ruby
class School &lt; ActiveRecord::Base
  has_many :squads
  has_many :students, :through => :squads
end</p>

<p>class Squad &lt; ActiveRecord::Base
  belongs_to :school
  has_many :students
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad
end
```</p>

<h3>Association(关联关系的使用)</h3>

<ul>
<li>association(force_reload = false)强制reload查数据库</li>
</ul>


<p>``` ruby
s = Squad.first
s.students
=> [#<Student id: 40, name: "学员1", squad_id: 1, created_at: "2013-12-11 02:43:53", updated_at: "2013-12-11 02:43:53", active: true>,
 #<Student id: 41, name: "学员2", squad_id: 1, created_at: "2013-12-11 02:43:56", updated_at: "2013-12-11 02:43:56", active: true>]</p>

<p>s.students.last.delete #把最后一个学员删除,那班级s只剩下一个学员</p>

<h1>可是还是两个学员</h1>

<p>s.students
=> [#<Student id: 40, name: "学员1", squad_id: 1, created_at: "2013-12-11 02:43:53", updated_at: "2013-12-11 02:43:53", active: true>,
 #<Student id: 41, name: "学员2", squad_id: 1, created_at: "2013-12-11 02:43:56", updated_at: "2013-12-11 02:43:56", active: true>]</p>

<h1>如果传入一个参数true</h1>

<p>s.students(true)
=> [#<Student id: 40, name: "学员1", squad_id: 1, created_at: "2013-12-11 02:43:53", updated_at: "2013-12-11 02:43:53", active: true>]
```</p>

<p>其实传入true就是去数据库查询,不直接从变量(<strong>s.students</strong>)取值
<code>
Student Load (0.8ms)  SELECT `students`.* FROM `students` WHERE `students`.`squad_id` = 1 AND `students`.`active` = 1
</code></p>

<ul>
<li>association=(associate)</li>
</ul>


<p>``` ruby</p>

<h1>good</h1>

<p>s = Student.first
s.squad = Squad.last
s.save</p>

<h1>bad</h1>

<p>s.squad_id = &lsquo;9&rsquo;.to_i
s.save
```</p>

<p>这种方式有两个好处,第一个,你不在白名单(attr_accessible)写上:squad_id,第二个你能保证squad_id就是正确存在的吗</p>

<p>最佳实践也是推鉴这种方式的</p>

<p><code>ruby
current_user.posts.build(params[:post])
</code></p>

<ul>
<li>collection&lt;&lt;(object, …)创建记录</li>
</ul>


<p>这是我们创建记录的主要手段之一</p>

<p><code>ruby
s = Squad.first
s.students &lt;&lt; Student.create(:name =&gt; "学员")
</code></p>

<ul>
<li>collection.delete(object, …)删除关联关系(不删除记录)</li>
</ul>


<p><code>`` ruby
s = Squad.first
s.students.delete(s.students.last) #删除最后一条,只是把值设为NULL
=&gt; SQL (0.6ms)  UPDATE</code>students<code>SET</code>squad_id<code>= NULL WHERE</code>students<code>.</code>squad_id<code>= 1 AND</code>students<code>.</code>active<code>= 1 AND</code>students<code>.</code>id` IN (43)</p>

<p>```</p>

<p>delete_all不用传参数就可以删除所有关联关系了</p>

<p>要保留数据的时候又要去掉关联关系用这种方式最好了</p>

<ul>
<li>collection.delete(object, …)删除记录</li>
</ul>


<p>``` ruby
s = Squad.first
st = s.first
s.students.destroy(st)</p>

<h1>是真正的删除记录</h1>

<p>DELETE FROM <code>students</code> WHERE <code>students</code>.<code>id</code> = 46</p>

<p>```</p>

<p>destroy_all不用传参数就可以删除所有关联的记录了</p>

<ul>
<li>collection_singular_ids=ids(更改关联关系)</li>
</ul>


<p>``` ruby
s = Squad.first</p>

<p>s.student_ids
=> [42, 43]</p>

<p>s.students_ids = [40, 43]</p>

<h1>会查一遍数据表students,没有的id你可别乱来哦</h1>

<p>Student Load (0.8ms)  SELECT <code>students</code>.* FROM <code>students</code> WHERE <code>students</code>.<code>id</code> IN (40, 43)</p>

<h1>不要42了就把关联关系去掉(设为NULL)</h1>

<p>SQL (0.6ms)  UPDATE <code>students</code> SET <code>squad_id</code> = NULL WHERE <code>students</code>.<code>squad_id</code> = 1 AND <code>students</code>.<code>active</code> = 1 AND <code>students</code>.<code>id</code> IN (42)</p>

<h1>把40加进去</h1>

<p>UPDATE <code>students</code> SET <code>squad_id</code> = 1, <code>updated_at</code> = &lsquo;2013-12-11 03:19:40&rsquo; WHERE <code>students</code>.<code>id</code> = 40</p>

<p>```</p>

<p>从表单的复选框传来的数据用这种方式解决最好了</p>

<p>最佳实践就是这么做滴</p>

<p>``` ruby 多角色管理
&lt;% for role in Role.all %></p>

<div>
  <%= check_box_tag "user[role_ids][]", role.id, @user.roles.include?(role) %>
  <%=h role.name %>
</div>


<p>&lt;% end %>
&lt;%= hidden_field_tag &ldquo;user[role_ids][]&rdquo;, &ldquo;&rdquo; %>
```</p>

<ul>
<li>collection.clear会把所有关联关系清除或者删掉</li>
</ul>


<p>``` ruby
s = Squad.first
s.students.clear</p>

<h1>只是把关联关系清除而已</h1>

<p>UPDATE <code>students</code> SET <code>squad_id</code> = NULL WHERE <code>students</code>.<code>squad_id</code> = 1 AND <code>students</code>.<code>active</code> = 1 AND <code>students</code>.<code>id</code> IN (42, 42)</p>

<p>```</p>

<p>如果不止想关联关系清除呢,那个就是要在has_many时加入:dependent => :destroy就可以了</p>

<p>其实看下clear的源码就知道原理</p>

<p>``` ruby</p>

<h1>File activerecord/lib/active_record/associations/association_collection.rb, line 244</h1>

<p>def clear
  return self if length.zero? # forces load_target if it hasn&rsquo;t happened already</p>

<p>  if @reflection.options[:dependent] &amp;&amp; @reflection.options[:dependent] == :destroy</p>

<pre><code>destroy_all
</code></pre>

<p>  else</p>

<pre><code>delete_all
</code></pre>

<p>  end</p>

<p>  self
end
```</p>

<ul>
<li>collection.exists?判断记录是否存在</li>
</ul>


<p>``` ruby
s = Squad.first</p>

<p>s.students.exists?(42)
=> true</p>

<p>s.students.exists?(Student.first)
=> true</p>

<p>s.students.exists?(:id => 42)
=> true
```</p>

<p>用<strong>exists?</strong>来判断比<strong>include?</strong>更灵活,<strong>include?</strong>只支持类似这样<code>inlcude?(Student.first)</code>的判断</p>

<h3>Association Parameter Reference(参数的使用)</h3>

<p>有些参数在上一篇<a href="http://yinsigan.github.io/blog/2013/12/10/rails-association/">rails association</a>已经提及过，例如polymorphic, :through等,这里再阐述几个比较常用或用处比较大的</p>

<ul>
<li>class_name</li>
</ul>


<p>查找实际的类名(model)</p>

<p>``` ruby</p>

<h1>默认情况下是:students的,如果要换个名字,就要指定实际的class_name</h1>

<p>has_many :newest_students, :class_name => &lsquo;Student&rsquo;, :order => &lsquo;created_at DESC&rsquo;</p>

<p>SELECT <code>students</code>.* FROM <code>students</code> WHERE <code>students</code>.<code>squad_id</code> = 1 ORDER BY created_at DESC
```</p>

<ul>
<li>conditions</li>
</ul>


<p>指定查询条件</p>

<p><code>ruby
has_many :students, :conditions =&gt; "active = 1"
</code></p>

<p>在rails 4已经用where代替conditions了</p>

<p>conditions有个要注意的地方</p>

<p><code>:conditions =&gt; "active = 1"</code>和<code>{active: true}</code>(Hash)是不一样的
当你用s.students.create或s.students.build创建student的时候,active的值会不一样
用<code>{active: true}</code>形式创建时不管你的active的默认值是否是true，创建的student的active都是true
而<code>:conditions =&gt; "active = 1"</code>就是看active的默认值</p>

<p>:conditions也可以接proc:<code>:conditions =&gt; proc { ["orders.created_at &gt; ?", 10.hours.ago] }</code></p>

<p>实际项目的代码如下:</p>

<p><code>ruby
class School &lt; ActiveRecord::Base
  has_many :students, :include =&gt; :user, :order =&gt; "users.name DESC", :conditions =&gt; "users.tp = 0"
  has_many :staff_users, :class_name =&gt; "User", :order =&gt; :name, :conditions =&gt; "tp = 1"
  has_many :staffs, :through =&gt; :users, :order =&gt; "users.name DESC", :conditions =&gt; "users.tp = 1"
end
</code></p>

<ul>
<li>counter_cache</li>
</ul>


<p>在数据库中记录孩子的数量</p>

<p><code>bash
rails g migration add_students_count_to_squads students_count:integer
</code></p>

<p>``` ruby
class AddStudentsCountToSquads &lt; ActiveRecord::Migration
  def change</p>

<pre><code>add_column :squads, :students_count, :string
Squad.reset_column_information
Squad.find_each do |p|
  Squad.update_counters p.id, :students_count =&gt; p.students.length
end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad, :counter_cache => true
end
```</p>

<p>默认的字段名是跟关联(has_many)的model是一致的,在上述的例子中就是<strong>students_count</strong>,如果想改变这个name也可以,给:counter_cache指定值就可以了,例如<code>:counter_cache =&gt; :children_count</code></p>

<p>当删除关联关系时(squad_id设为NULL)时,students_count不会更新</p>

<ul>
<li>dependent</li>
</ul>


<p>依赖性</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students, :dependent => :destroy
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad
end
```</p>

<p>如果传入<code>:dependent =&gt; :nullify</code>不删除数据,只删除关联数据</p>

<ul>
<li>foreign_key</li>
</ul>


<p>外键</p>

<p><code>ruby
class Topic &lt; ActiveRecord::Base
  belongs_to :creater, :class_name =&gt; 'User', :foreign_key =&gt; "creater_id"
end
</code></p>

<p>当你的model name跟foreign_key不一致时就可以手动指定关联的foreign_key
这样写当<code>topic.creater.try(:name)</code>就可以简单取得创建者的name了</p>

<ul>
<li>include</li>
</ul>


<p>包含查询</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad, :include => :school
end</p>

<p>class School &lt; ActiveRecord::Base
  has_many :squads
end</p>

<p>s = Student.first
s.squad</p>

<h1>查了schools这个表,把数据一并取了出来</h1>

<p>Squad Load (0.3ms)  SELECT <code>squads</code>.<em> FROM <code>squads</code> WHERE <code>squads</code>.<code>id</code> = 14 LIMIT 1
School Load (0.3ms)  SELECT <code>schools</code>.</em> FROM <code>schools</code> WHERE <code>schools</code>.<code>id</code> IN (1)</p>

<h1>前面已经查了schools的数据了,现在不会查sql的</h1>

<p>s.squad.school
```</p>

<p>当你要查<code>Student.first.squad.school</code>就方便多了</p>

<ul>
<li>touch</li>
</ul>


<p>当子类被创建或更改时,更新父类的updated_at</p>

<p>``` ruby
class Student &lt; ActiveRecord::Base
  belongs_to :squad, :touch => true
end</p>

<p>class Squad &lt; ActiveRecord::Base
  has_many :students
end</p>

<p>s = Student.first
s.name = &lsquo;学员&rsquo;
s.save</p>

<h1>其实就是把父的updated_at更新了一下</h1>

<p>UPDATE <code>students</code> SET <code>name</code> = &lsquo;3333333333333&rsquo;, <code>updated_at</code> = &lsquo;2013-12-11 14:59:47&rsquo; WHERE <code>students</code>.<code>id</code> = 86
Squad Load (0.6ms)  SELECT <code>squads</code>.* FROM <code>squads</code> WHERE <code>squads</code>.<code>id</code> = 14 LIMIT 1
SQL (0.7ms)  UPDATE <code>squads</code> SET <code>updated_at</code> = &lsquo;2013-12-11 14:59:47&rsquo; WHERE <code>squads</code>.<code>id</code> = 14
```</p>

<p>如果不想更新updated_at, 还可以指定更新具体的column,例如<code>:touch =&gt; :accessed_at</code></p>

<ul>
<li>validate</li>
</ul>


<p>跳过验证</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students, :validate => true
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad
  validates :name, :presence => true
end</p>

<h1>failure</h1>

<p>Student.create</p>

<h1>success</h1>

<p>s = Squad.first
s.students.create
```</p>

<p>在创建子对象时,可以跳过验证</p>

<ul>
<li>source</li>
</ul>


<p>指定查找源, 和has_one :through或has_many :through一起使用</p>

<p>``` ruby
class School &lt; ActiveRecord::Base
  has_many :squads
  has_many :squads_teachers, :through => :squads, :source => :teachers
end</p>

<p>class Squad &lt; ActiveRecord::Base
  has_many :teachers
  belongs_to :school
end</p>

<p>class Teacher &lt; ActiveRecord::Base
  belongs_to :squad
  belongs_to :staff
end</p>

<p>s = School.first
s.squads_teachers</p>

<h1>查找的是teachers表,不过teachers去joins squads表</h1>

<p>School Load (1.5ms)  SELECT <code>schools</code>.<em> FROM <code>schools</code> LIMIT 1
Teacher Load (90.0ms)  SELECT <code>teachers</code>.</em> FROM <code>teachers</code> INNER JOIN <code>squads</code> ON <code>teachers</code>.<code>squad_id</code> = <code>squads</code>.<code>id</code> WHERE <code>squads</code>.<code>school_id</code> = 1</p>

<h1>grades belongs_to staff</h1>

<p>has_many :grade_teachers, :through => :grades, :source => :staff  #年级组长
```</p>

<p>这种方式用得好真的好灵活</p>

<ul>
<li>group</li>
</ul>


<p>分组</p>

<p>``` ruby
class School &lt; ActiveRecord::Base
  has_many :students, :through => :squads, :group => &lsquo;squads.id&rsquo;
end</p>

<p>s = School.first
s.students</p>

<h1>原理就是在数据库查询的时候加个分组group</h1>

<p>Student Load (81.7ms)  SELECT <code>students</code>.* FROM <code>students</code> INNER JOIN <code>squads</code> ON <code>students</code>.<code>squad_id</code> = <code>squads</code>.<code>id</code> WHERE <code>squads</code>.<code>school_id</code> = 1 GROUP BY squads.id
```</p>

<ul>
<li>:uniq</li>
</ul>


<p>确保查到的数据是唯一的</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :staffs, :through => :teachers, :uniq => true
  has_many :teachers
end</p>

<p>class Staff &lt; ActiveRecord::Base
  has_many :squad, :through => :teachers
  has_many :teachers
end</p>

<p>class Teacher &lt; ActiveRecord::Base
  belongs_to :squad
  belongs_to :staff
end</p>

<p>s = Squad.first
staff = Staff.create
s.staff &lt; staff
s.staff &lt; staff</p>

<h1>如果没有:unqi => true,将会输出多个staffs,数据库也是存在的(相同的数据),加上:unqi => true将只会输出一条数据,这样才符合逻辑</h1>

<p>s.staff</p>

<p>```</p>

<p>在rails 4用-> { distinct }</p>

<ul>
<li>除了这些参数还有<strong>:readonly</strong>, <strong>:order</strong>, <strong>:select</strong>, <strong>:limit</strong>, <strong>:offset</strong>等</li>
</ul>


<h3>Association Callbacks</h3>

<ul>
<li>before_add 添加前</li>
<li>after_add 添加后</li>
<li>before_remove 删除前</li>
<li>after_remove  删除后</li>
</ul>


<p>这是关联关系的Callbacks</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students, :after_add => :update_accessed_at</p>

<p>  private</p>

<pre><code>def update_accessed_at(student)
  student.accessed_at = Time.now.utc
  student.save
end
</code></pre>

<p>end</p>

<p>s = Squad.first
s.students &lt;&lt; Student.create(:name => &ldquo;学员&rdquo;)
```</p>

<h2>学会了这些,可以对数据库更加理解,而且减少代码量(减少自己写数据库查询),优化了代码</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rails association]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/10/rails-association/"/>
    <updated>2013-12-10T13:13:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/10/rails-association</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://guides.rubyonrails.org/association_basics.html">rails guides association</a></li>
<li><a href="http://guides.rubyonrails.org/association_basics.html">rails api association</a></li>
<li><a href="http://ihower.tw/rails3/activerecord-relationships.html">rails 实战圣经-资料表关联</a></li>
<li><a href="http://railscasts.com/episodes/154-polymorphic-association">rails polymorphic-association</a></li>
</ul>


<h2>模型关联</h2>

<p>通过关键字(belongs_to, has_many等)把两个<strong>model</strong>(模型)关联起来,下面以我的开发经验和一些源码来解说每个模型关联</p>

<p>所有关键字如下:</p>

<ul>
<li>belongs_to</li>
<li>has_one</li>
<li>has_many</li>
<li>has_many :through</li>
<li>has_one :through</li>
<li>has_and_belongs_to_many</li>
</ul>


<h3>一对多</h3>

<p>通过<strong>has_many</strong>或<strong>has_many :through</strong>或自关联来定义,一个<strong>modelA</strong>有很多<strong>modelB</strong>,那些<strong>modelB</strong>都属于<strong>modelA</strong>例如一篇文章有很多评论, 一个班级有很多学员</p>

<h4>has_many</h4>

<p><img src="/images/rails_association/has_many_and_belongs_to.png"></p>

<!-- more -->


<p>``` ruby
class Comment &lt; ActiveRecord::Base
  belongs_to :artilce
end</p>

<p>class Article &lt; ActiveRecord::Base
  has_many :comments
end
```</p>

<p><strong>comments</strong>表必须要有一个<strong>foreign_key</strong>(article_id)才能实现两个表的关联</p>

<h4>has_many :through</h4>

<p><img src="/images/rails_association/has_many_through_three.png"></p>

<p>``` ruby
class kindergarten &lt; ActiveRecord::Base
  has_many :squads
  has_many :students, :through => :squads
end</p>

<p>class Squad &lt; ActiveRecord::Base
  belongs_to :kindergarten
  has_many :students
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad
end
```</p>

<p>这种方式适用于三层关系(祖,父,孙)的，而且在第三层不用写belongs_to第一层</p>

<h4>自关联(self join)</h4>

<p>foreign_key是可以指定你想要的任何字段,通过foreign_key我们可以实现自关联(Self Joins),即一个表中即定义了has_many又定义了belongs_to,例如<a href="http://yinsigan.github.io/blog/2013/12/09/acts-as-treeyuan-ma-fen-xi/">acts_as_tree</a>就是这样实现的,它是一个树结构,它是这样实现的</p>

<p><code>ruby comment.rb
class Comment &lt; ActiveRecord::Base
  has_many   :children, :class_name =&gt; 'Comment', :foreign_key =&gt; :parent_id
  belongs_to :parent,   :class_name =&gt; 'Comment', :foreign_key =&gt; :parent_id
end
</code></p>

<h3>一对一</h3>

<p>通过<strong>has_one</strong>或<strong>has_one :through</strong>来定义,一个<strong>modelA</strong>有一个<strong>modelB</strong>, 那么<strong>modelB</strong>属于<strong>modelA</strong>,他们之间是一对一的关系,例如一个男人只有一个妻子,一个人只有一个身份证都是现实中一对一的关系</p>

<h4>has_one</h4>

<p><img src="/images/rails_association/has_one_belongs_to.png"></p>

<p>``` ruby
class User &lt; ActiveRecord::Base
  has_one :profile
end</p>

<p>class Profile &lt; ActiveRecord::Base
  belongs_to :user
end
```</p>

<p>一对一的关系也是要通过foreign_key来关联的</p>

<h4>has_one :through</h4>

<p><img src="/images/rails_association/has_one_through.png"></p>

<p>``` ruby
class User &lt; ActiveRecord::Base
  has_one :profile
  has_one :proile_detail, :through => :profile
end</p>

<p>class Profile &lt; ActiveRecord::Base
  belongs_to :user
  has_one :proile_detail
end</p>

<p>class ProfileDetail &lt; ActiveRecord::Base
  belongs_to :profile
end
```</p>

<p>这个<strong>has_one :through</strong>的原理跟<strong>has_many :through</strong>的差不多,都是三级关系</p>

<h3>多对多</h3>

<p>能过<strong>has_many :through</strong>或<strong>has_many_and_belongs_to</strong>来定义,<strong>modelA</strong>有很多<strong>modelB</strong>,<strong>modelB</strong>也有很多<strong>modelA</strong>,它们之间是多对多的关系,例如人有很多的钱,钱属于很多人</p>

<h4>has_many :through</h4>

<p><img src="/images/rails_association/has_many_through.png"></p>

<p>``` ruby
class Staff &lt; ActiveRecord::Base
  has_many :teachers
  has_many :squads, :through => :teachers
end</p>

<p>class Squad &lt; ActiveRecord::Base
  has_many :teachers
  has_many :squads, :through => :teachers
end</p>

<p>class Teacher &lt; ActiveRecord::Base
  belongs_to :squad
  belongs_to :staff
end
```</p>

<p>多对多的实现是要通过中间表的,而has_many :through这种方式的中间表有两个好处,第一个是表名你可以自己随便命名(比较人性化),第二个好处你可以在中间表上加属性</p>

<h4>has_many_and_belongs_to</h4>

<p><img src="/images/rails_association/has_many_and_belongs_to.png"></p>

<p><code>ruby
class Role &lt; ActiveRecord::Base
  has_and_belongs_to_many :operates
end
class Operate &lt; ActiveRecord::Base
  has_and_belongs_to_many :roles
end
</code></p>

<p>这种方式对中间表的命名是有规定的,连中间表的model也不用写,<strong>has_many_and_belongs_to</strong>是rails提供的,缺点是不能灵活控制,优点是方便</p>

<p>在migration创建表不创建id(没必要)</p>

<h3>Polymorphic Associations(多态)</h3>

<p>上述都是两个表进行关联,有的不需要中间表,有的不需要,如果要实现三个表以上的关联呢,这个时候就要用到多态了,例如我们不止在文章里可以加评论,在新闻里也可以评论,在贴子里都可以</p>

<p><img src="/images/rails_association/polymorphic.png"></p>

<p>``` ruby
class Followable &lt; ActiveRecord::Base
  belongs_to :followable, :polymorphic => true
end</p>

<p>class Book &lt; ActiveRecord::Base
  has_many :follow, :as => :followable
end</p>

<p>class User &lt; ActiveRecord::Base
  has_many :follow, :as => :followable
end</p>

<p>class Comment &lt; ActiveRecord::Base
  has_many :follow, :as => :followable
end
```</p>

<p>多态的方法很灵活,它也需要一个中间表,但是他不止能关联一个表,而关联无数个表,在中间表中一个字段是存关联表的类型,一个存id,它通过这两个字段来实现关联所有表的</p>

<h3>单表继承</h3>

<p>有些模型的相似度达到百分之九十,甚至有些只有一个字段的值不同,没必要复制一遍model，再改不同的字段</p>

<p>这个时候可以用一个字段但存的值是不同的,这种方式可以的,只是因为类型不同,数据和逻辑不同,控制器即使写两套，还是要做各种判断,代码会变得很乱,很麻烦</p>

<p>这个时候一个好的解决方案就是用单表继承</p>

<p><img src="/images/rails_association/single_table_inheritance.png"></p>

<p>``` ruby
class GrowthRecord &lt; ActiveRecord::Base
end</p>

<p>class HomeGrowthRecord &lt; GrowthRecord
end</p>

<p>class GardenGrowthRecord &lt; GrowthRecord
end
```</p>

<p>GrowthRecord必须存一个字段叫type:string的,这个是自动处理的</p>

<p>如果不让GrowthRecord被实例化,可以加self.abstract_class = true,这样GrowthRecord就被锁住了</p>

<h2>总结</h2>

<p>学习这些可以让我们对rails association更理解,理解如何设计数据库,处理复杂的逻辑关系</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[acts_as_tree源码分析]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/09/acts-as-treeyuan-ma-fen-xi/"/>
    <updated>2013-12-09T14:30:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/09/acts-as-treeyuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<ul>
<li><a href="https://github.com/amerine/acts_as_tree">acts_as_tree</a></li>
</ul>


<h3>这个gem是干什么的?原理是什么?</h3>

<p>这个gem是用来实现树型结构的,例如一个分类(category),下面还有子分类,这个时候就可以用它了,还有,你回复了一个贴子,别人再来回复你，这个时候也可以用它。一个菜单之下还有子菜单，子菜单之下又可以有子菜单,子菜单之下有菜单项，它可以实现一种树型结构的菜单。它的原理也很简单,在模型中是实现了一个自关联,假如在一个comment(评论)model中,定义一个children(孩子),再定义一个parent(父), :class_name都是'Comment'。那他们怎么实现关联的,也就是说孩子要知道父亲是谁,父亲要知道它有哪些孩子,它在数据存储中是通过一个字段来关联的,在这个gem中这个字段叫<strong>parent_id</strong>假如我们创建一个根(root), <code>root = Comment.create</code>, 这个时候<strong>root</strong>*的parent_id是null,它是一个根,<code>children = root.children.create</code>,这个<strong>children</strong>是<strong>root</strong>的一个孩子,那<strong>children</strong>的<strong>parent_id</strong>就是<strong>root</strong>的<strong>id</strong></p>

<p>```
  菜单
   |<em> 系统设置
   |    |</em> 模版设置
   |    |<em> 表格设置
   |</em> 人员管理</p>

<pre><code>    |_ 教职工管理
    |_ 学员管理
</code></pre>

<p>```</p>

<p>children和parent的关系是这样实现的</p>

<p><code>ruby
belongs_to :parent...
has_many   :children...
</code></p>

<p>数据表是这样存储的</p>

<!-- more -->


<p><img src="/images/acts_as_tree_table.png"></p>

<h3>分析</h3>

<p>它的核心文件只有一个<strong>lib/acts_as_tree.rb</strong></p>

<p>``` ruby lib/acts_as_tree.rb</p>

<p>require &lsquo;acts_as_tree/version&rsquo;</p>

<p>module ActsAsTree</p>

<p>  if defined? Rails::Railtie</p>

<pre><code>require 'acts_as_tree/railtie'
</code></pre>

<p>  elsif defined? Rails::Initializer</p>

<pre><code>raise "acts_as_tree 1.0 is not compatible with Rails 2.3 or older"
</code></pre>

<p>  end</p>

<p>  def self.included(base)</p>

<pre><code>base.extend(ClassMethods)
</code></pre>

<p>  end</p>

<p>  # Specify this +acts_as+ extension if you want to model a tree structure
  # by providing a parent association and a children association. This
  # requires that you have a foreign key column, which by default is called
  # +parent_id+.
  #
  #   class Category &lt; ActiveRecord::Base
  #     include ActsAsTree
  #
  #     acts_as_tree :order => &ldquo;name&rdquo;
  #   end
  #
  #   Example:
  #   root
  #    _ child1
  #         _ subchild1
  #         _ subchild2
  #
  #   root      = Category.create(&ldquo;name&rdquo; => &ldquo;root&rdquo;)
  #   child1    = root.children.create(&ldquo;name&rdquo; => &ldquo;child1&rdquo;)
  #   subchild1 = child1.children.create(&ldquo;name&rdquo; => &ldquo;subchild1&rdquo;)
  #
  #   root.parent   # => nil
  #   child1.parent # => root
  #   root.children # => [child1]
  #   root.children.first.children.first # => subchild1
  #
  # In addition to the parent and children associations, the following
  # instance methods are added to the class after calling
  # <tt>acts_as_tree</tt>:
  # * <tt>siblings</tt> &ndash; Returns all the children of the parent, excluding
  #                       the current node (<tt>[subchild2]</tt> when called
  #                       on <tt>subchild1</tt>)
  # * <tt>self_and_siblings</tt> &ndash; Returns all the children of the parent,
  #                                including the current node (<tt>[subchild1, subchild2]</tt>
  #                                when called on <tt>subchild1</tt>)
  # * <tt>ancestors</tt> &ndash; Returns all the ancestors of the current node
  #                        (<tt>[child1, root]</tt> when called on <tt>subchild2</tt>)
  # * <tt>root</tt> &ndash; Returns the root of the current node (<tt>root</tt>
  #                   when called on <tt>subchild2</tt>)
  module ClassMethods</p>

<pre><code># Configuration options are:
#
# * &lt;tt&gt;foreign_key&lt;/tt&gt; - specifies the column name to use for tracking
#                          of the tree (default: +parent_id+)
# * &lt;tt&gt;order&lt;/tt&gt; - makes it possible to sort the children according to
#                    this SQL snippet.
# * &lt;tt&gt;counter_cache&lt;/tt&gt; - keeps a count in a +children_count+ column
#                            if set to +true+ (default: +false+).

# 是通过这个方法来明确rails model association的(has_many belongs_to),而且这个方法会导入InstanceMethods model
def acts_as_tree(options = {})

  # 默认的配置选项, dependent当你删除节点时，连同子节点全部删除
  configuration = {
    foreign_key:   "parent_id",
    order:         nil,
    counter_cache: nil,
    dependent:     :destroy
  }

  # 替换原来的方法或增加新的option
  configuration.update(options) if options.is_a?(Hash)

  # 定义一个自关联的parent, 如果设count_cache: true那就得在数据表中加入comments_count(comments是你的表名), foreign_key是parent_id，主要是通过它来关联parent和children
  belongs_to :parent, class_name:    name,
    foreign_key:   configuration[:foreign_key],
    counter_cache: configuration[:counter_cache],
    inverse_of:    :children

  # 跟上述差不多,更多的可以看rails guides associations
  if ActiveRecord::VERSION::MAJOR &gt;= 4
    has_many :children, lambda { order configuration[:order] },
      class_name:  name,
      foreign_key: configuration[:foreign_key],
      dependent:   configuration[:dependent],
      inverse_of:  :parent
  else
    has_many :children, class_name:  name,
      foreign_key: configuration[:foreign_key],
      order:       configuration[:order],
      dependent:   configuration[:dependent],
      inverse_of:  :parent
  end

  # 下面都是类的实例方法,相当于class &lt;&lt; self
  class_eval &lt;&lt;-EOV
    # 包含实例方法
    include ActsAsTree::InstanceMethods

    # update之后更新counter_cache, 关于create之后更新counter_cache是自动进行的
    after_update :update_parents_counter_cache

    # 以一个数组形式返回所有的根,可通过Comment.roots这样调用
    def self.roots
      # %Q的用法参考这里http://simpleror.wordpress.com/2009/03/15/q-q-w-w-x-r-s/
      # fetch是一个Hash的方法,对传过来的值作为key来取值,没有这个key就用第二个参数来代替
      # 在老版本的acts_as_tree中用#{configuration[:order].nil? ? "nil" : %Q{"#{configuration[:order]}"}},明显用fetch简洁好多
      order_option = %Q{#{configuration.fetch :order, "nil"}}
      # nil查询在老版本的acts_as_tree中用is NULL
      where(:#{configuration[:foreign_key]} =&gt; nil).order(order_option)
    end

    # 返回数据中的根
    def self.root
      order_option = %Q{#{configuration.fetch :order, "nil"}}
      self.roots.first
    end
  EOV
end
</code></pre>

<p>  end</p>

<p>  # extend Presentation,这个module下定义的都是类方法,用Comment.tree_view来调用
  module Presentation</p>

<pre><code># show records in a tree view
# Example:
# root
#  |_ child1
#  |    |_ subchild1
#  |    |_ subchild2
#  |_ child2
#       |_ subchild3
#       |_ subchild4
#
# 看上面的例子，用一种良好阅读的方式返回树的形状
# 树的遍历要用到递归
def tree_view(label_method = :to_s,  node = nil, level = -1)
  if node.nil?
    puts "root"
    # roots是个类方法,返回所有包含根节点的数组
    nodes = roots
  else
    label = "|_ #{node.send(label_method)}"
    if level == 0
      puts " #{label}"
    else
      puts " |#{"    "*level}#{label}"
    end
    nodes = node.children
  end
  # 1.首先默认传入node=nil, level=-1,这个时候会执行node.nil?，在第一行输出root,接着返回包含根节点的数组
  # 2.遍历由根节点组成的数组,执行tree_view递归函数,而这个时候,node不等于nil,level=0,执行level == 0下面一句输出第一个根节点(类似|_root)
  # 3.接着把这个根节点的孩子传给nodes去执行第二步, 这个node是不会等于nil的,level也将大于1,将会执行puts " |#{"    "*level}#{label}"这一行,在第二层树中level等于1,在输出时前面会空出一份空白,假如第二层树中有孩子,还会继续遍历,直到没有孩子
  nodes.each do |child|
    tree_view(label_method, child, level+1)
  end
end
</code></pre>

<p>  end</p>

<p>  # 下面定义都是实例方法
  module InstanceMethods</p>

<pre><code># Returns list of ancestors, starting from parent until root.
#
#   subchild1.ancestors # =&gt; [child1, root]
# 返回祖先链
def ancestors
  node, nodes = self, []
  nodes &lt;&lt; node = node.parent while node.parent
  nodes
end

# Returns the root node of the tree.
# 返回根节点
def root
  node = self
  node = node.parent while node.parent
  node
end

# Returns all siblings of the current node.
#
#   subchild1.siblings # =&gt; [subchild2]
# 返回所有兄弟节点
def siblings
  # 减掉自己就是兄弟节点
  self_and_siblings - [self]
end

# Returns all siblings and a reference to the current node.
#
#   subchild1.self_and_siblings # =&gt; [subchild1, subchild2]
# 返回自身加上兄弟节点
def self_and_siblings
  # 如果不是根节点就把根节点的所有孩子都返回
  # 否则的话就把所有根节点返回
  # class能引用到自身的类
  parent ? parent.children : self.class.roots
end

# Returns children (without subchildren) and current node itself.
#
#   root.self_and_children # =&gt; [root, child1]
# 返回自身和孩子
def self_and_children
  [self] + self.children
end

# Returns ancestors and current node itself.
#
#   subchild1.self_and_ancestors # =&gt; [subchild1, child1, root]
# 返回自己和祖先
def self_and_ancestors
  [self] + self.ancestors
end

# Returns true if node has no parent, false otherwise
#
#   subchild1.root? # =&gt; false
#   root.root?      # =&gt; true
# 判断是否是根节点
def root?
  parent.nil?
end

# Returns true if node has no children, false otherwise
#
#   subchild1.leaf? # =&gt; true
#   child1.leaf?    # =&gt; false
# 没有孩子了就是叶子节点
def leaf?
  children.count == 0
end

private

# 为使这个方法生效必须有:counter_cache =&gt; :children_count和children_count这个字段,不然你自己可以重写这个方法, :counter_cache是可以自定义的,默认是children的表名加cache，例如comments_cache
def update_parents_counter_cache
  # 首先用respond_to?判断是否有这个方法(:children_count)
  # 通过Active Model Dirty来判断是否改变了parent_id
  # 关于Active Model Dirty可以看http://api.rubyonrails.org/classes/ActiveModel/Dirty.html
  if self.respond_to?(:children_count) &amp;&amp; parent_id_changed?
    # decrement_counter是给:children_count减少1, parent_id_was是旧的值
    self.class.decrement_counter(:children_count, parent_id_was)
    # increment_counter是给:children_count增加1, parent_id是新的值
    # 具体的decrement_counter和increment_counter可以看http://api.rubyonrails.org/classes/ActiveRecord/CounterCache/ClassMethods.html
    self.class.increment_counter(:children_count, parent_id)
  end
end
</code></pre>

<p>  end
end</p>

<h1>Deprecating the following code in the future.</h1>

<p>require &lsquo;acts_as_tree/active_record/acts/tree&rsquo;</p>

<p>```</p>

<h3>总结</h3>

<p>通过这个gem我们可以学一些查询方法,例如关于根节点，祖先节点的查找啊,还可以学习自关联的写法,一些递归写法等</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[acts_as_follower源码分析]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/03/acts-as-followeryuan-ma-fen-xi/"/>
    <updated>2013-12-03T16:41:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/03/acts-as-followeryuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<ul>
<li><a href="https://github.com/tcocca/acts_as_follower">acts_as_follower</a></li>
</ul>


<h3>这个gem是做什么的?原理是什么?</h3>

<p>这个gem主要是用来实现类似twitter那种关注，新浪那种收听的功能
主要是两个model的关联,例如一个用户订阅了一本书,我们可以这样实现<code>User.first.follow(Book.first)</code></p>

<p>它在实现是就是利用两个多态，一个叫followable(被follow者), 一个叫followable(跟随者),把每个对象的类名字符串和id存进数据库实现关联,其他代码就实现了关于两者的查询代码, 下面是两者的关系</p>

<p><code>ruby
has_many :followings, :as =&gt; :followable, :dependent =&gt; :destroy, :class_name =&gt; 'Follow'
has_many :follows, :as =&gt; :follower, :dependent =&gt; :destroy
</code></p>

<p><code>ruby follow.rb
belongs_to :followable, :polymorphic =&gt; true
belongs_to :follower,   :polymorphic =&gt; true
</code></p>

<hr />

<h3>来看一下它的数据结构</h3>

<p>目录树结构</p>

<p><img src="/images/acts_as_follower_file_tree.png"></p>

<p>结构库表结构</p>

<p><img src="/images/acts_as_follower_table_tree.png"></p>

<p>主要有五个字段,分别是<strong>blocked</strong>, <strong>followable_id</strong>, <strong>followable_type</strong>, <strong>follower_id</strong>, <strong>follower_type</strong>, 主要是分为两个多态(<strong>follower</strong>, <strong>followerable</strong>), 例如一个用户订阅了一本书, <strong>followerable</strong>可以存<strong>Book</strong>和它的<strong>id</strong>, 而<strong>follower</strong>这个多态存<strong>User</strong>和它的<strong>id</strong></p>

<hr />

<h3>接下来就来分晰啦</h3>

<h4>源码目录结构功能介绍</h4>

<!-- more -->


<ul>
<li>lib/acts_as_follower.rb: 主文件,主要定义了ActsAsFollower这个model(每个gem都会做差不多的事),还包括一些autoload语句，做的事主要是require你的所用到的rb文件啦</li>
</ul>


<p>``` ruby lib/acts_as_follower
require &ldquo;acts_as_follower/version&rdquo;</p>

<p>module ActsAsFollower
  autoload :Follower,     &lsquo;acts_as_follower/follower&rsquo;
  autoload :Followable,   &lsquo;acts_as_follower/followable&rsquo;
  autoload :FollowerLib,  &lsquo;acts_as_follower/follower_lib&rsquo;
  autoload :FollowScopes, &lsquo;acts_as_follower/follow_scopes&rsquo;</p>

<p>  require &lsquo;acts_as_follower/railtie&rsquo; if defined?(Rails) &amp;&amp; Rails::VERSION::MAJOR >= 3
end
```</p>

<ul>
<li>lib/acts_as_follower/railtie.rb: 这个文件的作用就大了,在model(继承自<strong>ActiveRecord::Base</strong>)能使用<strong>acts_as_followable</strong>,<strong>acts_as_follower</strong>这个多亏了这个文件,其实这个文件使用了一个叫railtie的rails部件,它官方的定义是这样的:<strong>Railtie is the core of the Rails framework and provides several hooks to extend Rails and/or modify the initialization process</strong>, 它能修改一些启动信息,在加载ActiveRecord部件时执行<code>include ActsAsFollower::Follower</code>这样的语句,以后每个继承自ActiveRecord::Base的class都能使用ActsAsFollower::Follower下面定义的方法(而acts_as_follower就是在这个文件里定义的)，其实可以用类似这样的写法<code>ActiveRecord::Base.send(:include, Juixe::Acts::Commentable)</code>来实现相同的目的,关于rails railtie的详细信息可查看<a href="http://api.rubyonrails.org/classes/Rails/Railtie.html">rails railtie</a>和<a href="http://ihower.tw/blog/archives/4873">Rails3: Railtie 和 Plugins 系統</a></li>
</ul>


<p>``` ruby lib/acts_as_follower/railtie.rb
require &lsquo;acts_as_follower&rsquo;
require &lsquo;rails&rsquo;</p>

<p>module ActsAsFollower
  class Railtie &lt; Rails::Railtie</p>

<pre><code>initializer "acts_as_follower.active_record" do |app|
  ActiveSupport.on_load :active_record do
    include ActsAsFollower::Follower
    include ActsAsFollower::Followable
  end
end
</code></pre>

<p>  end
end
```</p>

<ul>
<li>lib/acts_as_follower/followable.rb: 这个文件主要服务于被follow的对象,它定义了好多用于被<strong>follow</strong>的实例方法,包括<strong>followers_by_type</strong>, <strong>followers_count</strong>,它是这样来调用的,例如<code>Book.first.followers_count</code>, <code>Book.first.followers_by_type('User')</code></li>
</ul>


<p>``` ruby lib/acts_as_follower/followable.rb</p>

<h1>被follow</h1>

<p>module ActsAsFollower #:nodoc:</p>

<p>  # 由上面可知ActiveRecord会include下面的Followable
  module Followable</p>

<pre><code># 这种写法很常见
def self.included(base)
  base.extend ClassMethods
end

# ClassMethods下面定义的是实例方法,ActiveRecord::Base可直接用，也就是说可以直接在继承自ActiveRecord::Base的model下用
module ClassMethods
  def acts_as_followable
    has_many :followings, :as =&gt; :followable, :dependent =&gt; :destroy, :class_name =&gt; 'Follow'
    # 下面的实例方法
    include ActsAsFollower::Followable::InstanceMethods
    # 这个下文有说
    include ActsAsFollower::FollowerLib
  end
end

# 下面的都是实例方法可用于被follow的实例来调用,下面的self都是被follow对象的实例
module InstanceMethods

  # Returns the number of followers a record has.
  # 返回followins的数量,而unblocked在lib/acts_as_followable/follow_scope.rb定义,只是一个简单的where scope
  def followers_count
    self.followings.unblocked.count
  end

  # Returns the followers by a given type
  # 下面主要是一个查询语句,constantize的定义见http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html
  # 而parent_class_name的定义在lib/acts_as_followable/follower_lib.rb,很简单,主要是返回class名字
  def followers_by_type(follower_type, options={})
    # parent_class_name是把一个实例转成类的字符串,例如'Topic', 'Article'等
    follows = follower_type.constantize.
      joins(:follows).
      where('follows.blocked'         =&gt; false,
            'follows.followable_id'   =&gt; self.id,
            'follows.followable_type' =&gt; parent_class_name(self),
            'follows.follower_type'   =&gt; follower_type)
    if options.has_key?(:limit)
      follows = follows.limit(options[:limit])
    end
    if options.has_key?(:includes)
      follows = follows.includes(options[:includes])
    end
    follows
  end

  # 返回所有follower的数量
  def followers_by_type_count(follower_type)
    self.followings.unblocked.for_follower_type(follower_type).count
  end

  # Allows magic names on followers_by_type
  # e.g. user_followers == followers_by_type('User')
  # Allows magic names on followers_by_type_count
  # e.g. count_user_followers == followers_by_type_count('User')
  # 实现更加灵活的查询
  def method_missing(m, *args)
    if m.to_s[/count_(.+)_followers/]
      followers_by_type_count($1.singularize.classify)
    elsif m.to_s[/(.+)_followers/]
      followers_by_type($1.singularize.classify)
    else
      super
    end
  end

  # 返回follow的数量
  def blocked_followers_count
    self.followings.blocked.count
  end

  # Returns the followings records scoped
  def followers_scoped
    # 因为follow belongs_to follower
    self.followings.includes(:follower)
  end

  # apply_options_to_scope是定义在lib/acts_as_followable/follower_lib.rb的一个方法,只要是过滤参数,把参数提取加到where scope中
  # 返回所有followers
  def followers(options={})
    followers_scope = followers_scoped.unblocked
    followers_scope = apply_options_to_scope(followers_scope, options)
    # 取出所有follower
    followers_scope.to_a.collect{|f| f.follower}
  end

  def blocks(options={})
    blocked_followers_scope = followers_scoped.blocked
    blocked_followers_scope = apply_options_to_scope(blocked_followers_scope, options)
    blocked_followers_scope.to_a.collect{|f| f.follower}
  end

  # Returns true if the current instance is followed by the passed record
  # Returns false if the current instance is blocked by the passed record or no follow is found
  # 查看是否被follow
  def followed_by?(follower)
    self.followings.unblocked.for_follower(follower).first.present?
  end

  # 如果查到记录就变成true，没有就创建那条记录
  def block(follower)
    get_follow_for(follower) ? block_existing_follow(follower) : block_future_follow(follower)
  end

  # 把following的记录删除
  def unblock(follower)
    get_follow_for(follower).try(:delete)
  end

  # 返回是否被follower, for_follower是个where scope
  def get_follow_for(follower)
    self.followings.for_follower(follower).first
  end

  private

  # 创建following记录
  def block_future_follow(follower)
    Follow.create(:followable =&gt; self, :follower =&gt; follower, :blocked =&gt; true)
  end

  # block!会把blocked属性变成true
  def block_existing_follow(follower)
    get_follow_for(follower).block!
  end

end
</code></pre>

<p>  end
end</p>

<p>```</p>

<ul>
<li>lib/acts_as_follower/follower.rb: 这是一个关于<strong>follower</strong>(叫做跟随者), 跟<strong>followable.rb</strong>的作用差不多，只是是反过来的</li>
</ul>


<p>``` ruby lib/acts_as_follower/follower.rb
module ActsAsFollower #:nodoc:
  module Follower</p>

<pre><code># active_record会include
def self.included(base)
  base.extend ClassMethods
end

module ClassMethods
  # 在model里就可以用acts_as_follower
  def acts_as_follower
    has_many :follows, :as =&gt; :follower, :dependent =&gt; :destroy
    # 具体类加载实例方法
    include ActsAsFollower::Follower::InstanceMethods
    # 具体类加载FollowerLib库方法
    include ActsAsFollower::FollowerLib
  end
end

module InstanceMethods

  # Returns true if this instance is following the object passed as an argument.
  # 是否following某个followable
  def following?(followable)
    0 &lt; Follow.unblocked.for_follower(self).for_followable(followable).count
  end

  # Returns the number of objects this instance is following.
  # 在数据表中查看这个follower总共跟随了多少followable
  def follow_count
    Follow.unblocked.for_follower(self).count
  end

  # Creates a new follow record for this instance to follow the passed object.
  # Does not allow duplicate records to be created.
  # follow某followable
  def follow(followable)
    if self != followable
      self.follows.find_or_create_by(followable_id: followable.id, followable_type: parent_class_name(followable))
    end
  end

  # Deletes the follow record if it exists.
  def stop_following(followable)
    # get_follow是用followable来找到那条follow记录然后把它删除掉
    if follow = get_follow(followable)
      follow.destroy
    end
  end

  # returns the follows records to the current instance
  def follows_scoped
    self.follows.unblocked.includes(:followable)
  end

  # Returns the follow records related to this instance by type.
  def follows_by_type(followable_type, options={})
    follows_scope  = follows_scoped.for_followable_type(followable_type)
    follows_scope = apply_options_to_scope(follows_scope, options)
  end

  # Returns the follow records related to this instance with the followable included.
  def all_follows(options={})
    follows_scope = follows_scoped
    follows_scope = apply_options_to_scope(follows_scope, options)
  end

  # Returns the actual records which this instance is following.
  def all_following(options={})
    all_follows(options).collect{ |f| f.followable }
  end

  # Returns the actual records of a particular type which this record is following.
  def following_by_type(followable_type, options={})
    followables = followable_type.constantize.
      joins(:followings).
      where('follows.blocked'         =&gt; false,
            'follows.follower_id'     =&gt; self.id,
            'follows.follower_type'   =&gt; parent_class_name(self),
            'follows.followable_type' =&gt; followable_type)
    if options.has_key?(:limit)
      followables = followables.limit(options[:limit])
    end
    if options.has_key?(:includes)
      followables = followables.includes(options[:includes])
    end
    followables
  end

  def following_by_type_count(followable_type)
    follows.unblocked.for_followable_type(followable_type).count
  end

  # Allows magic names on following_by_type
  # e.g. following_users == following_by_type('User')
  # Allows magic names on following_by_type_count
  # e.g. following_users_count == following_by_type_count('User')
  def method_missing(m, *args)
    if m.to_s[/following_(.+)_count/]
      following_by_type_count($1.singularize.classify)
    elsif m.to_s[/following_(.+)/]
      following_by_type($1.singularize.classify)
    else
      super
    end
  end

  # Returns a follow record for the current instance and followable object.
  def get_follow(followable)
    self.follows.unblocked.for_followable(followable).first
  end

end
</code></pre>

<p>  end
end</p>

<p><code>``
+ lib/acts_as_follower/follow_scopes.rb: 这里封装的都是一些查询语句,在**follow.rb**文件里有一句</code>extend ActsAsFollower::FollowScopes`可以在实例上使用这些方法</p>

<p>``` ruby lib/acts_as_follower/follow_scopes.rb
module ActsAsFollower #:nodoc:
  module FollowScopes</p>

<pre><code>def for_follower(follower)
  where(:follower_id =&gt; follower.id,
        :follower_type =&gt; parent_class_name(follower))
end

def for_followable(followable)
  where(:followable_id =&gt; followable.id, :followable_type =&gt; parent_class_name(followable))
end

def for_follower_type(follower_type)
  where(:follower_type =&gt; follower_type)
end

def for_followable_type(followable_type)
  where(:followable_type =&gt; followable_type)
end

def recent(from)
  where(["created_at &gt; ?", (from || 2.weeks.ago).to_s(:db)])
end

def descending
  order("follows.created_at DESC")
end

def unblocked
  where(:blocked =&gt; false)
end

def blocked
  where(:blocked =&gt; true)
end
</code></pre>

<p>  end
end
```</p>

<ul>
<li>lib/acts_as_follower/follower_lib.rb: 这里封装了两个方法,上文有讲过,<strong>follow.rb</strong>文件里有一句<code>extend ActsAsFollower::FollowerLib</code></li>
</ul>


<p>``` ruby lib/acts_as_follower/follower_lib.rb
module ActsAsFollower
  module FollowerLib</p>

<pre><code>private

# Retrieves the parent class name if using STI.
def parent_class_name(obj)
  if obj.class.superclass != ActiveRecord::Base
    return obj.class.superclass.name
  end
  return obj.class.name
end

def apply_options_to_scope(scope, options = {})
  if options.has_key?(:limit)
    scope = scope.limit(options[:limit])
  end
  if options.has_key?(:includes)
    scope = scope.includes(options[:includes])
  end
  if options.has_key?(:joins)
    scope = scope.joins(options[:joins])
  end
  if options.has_key?(:where)
    scope = scope.order(options[:where])
  end
  if options.has_key?(:order)
    scope = scope.order(options[:order])
  end
  scope
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<ul>
<li>lib/acts_as_follower/generators/templates/follow.rb: 这个文件是用来生成模版的,生成的是一个model文件,放在app/models下,它是一个中间表,是所有<strong>follower</strong>和<strong>followable</strong>的链接点</li>
</ul>


<p>``` ruby app/models/follow.rb
class Follow &lt; ActiveRecord::Base</p>

<p>  extend ActsAsFollower::FollowerLib
  extend ActsAsFollower::FollowScopes</p>

<p>  # NOTE: Follows belong to the &ldquo;followable&rdquo; interface, and also to followers
  belongs_to :followable, :polymorphic => true
  belongs_to :follower,   :polymorphic => true</p>

<p>  def block!</p>

<pre><code>self.update_attribute(:blocked, true)
</code></pre>

<p>  end</p>

<p>end
```</p>

<h3>总结</h3>

<p>学会组织代码的能力和一些rails的内部的东西,学习这个gem查询一些数据的方法,还有双重多态的写法</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Acts As Commentable source analyse]]></title>
    <link href="http://yinsigan.github.io/blog/2013/11/26/acts-as-commentable-source-analyse/"/>
    <updated>2013-11-26T11:49:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/11/26/acts-as-commentable-source-analyse</id>
    <content type="html"><![CDATA[<ul>
<li><a href="https://github.com/jackdempsey/acts_as_commentable">acts_as_commentable</a></li>
</ul>


<h3>这个gem是做什么的?原理是什么?</h3>

<p>这个gem是用来实现评论,它跟一般的评论没什么区别,只是这个gem把一些代码进行了封装,这是我们可以学习的地方.</p>

<p>它使用也很简单,只要在model里写上<code>acts_as_commentable</code>,就可以使用评论了,其实<code>acts_as_commentable</code>在实现上就等于
<code>has_many :comments, :as =&gt; :commentable</code>, comment这个model是一个简单的多态,它在数据表中的存储是这样的。</p>

<p><img src="/images/acts_as_comment_table.png"></p>

<p>其实最主要的就是两个字段commentable_id, commentable_type,一个简单的多态</p>

<p>由于<code>has_many :comments</code>那就可以进行很多操作，例如创建一条评论</p>

<p><code>ruby
Post.first.comments.create(:title =&gt; "First comment.", :comment =&gt; "This is the first comment.")
</code></p>

<p>经过这样的操作之后,在数据库中就会产生如下如果</p>

<p><img src="/images/acts_as_comment_table_result.png"></p>

<p>而这个存储方式是由rails自动处理的,更多的rails关系模型可查看<a href="http://guides.rubyonrails.org/association_basics.html">rails guides</a></p>

<h4>分析</h4>

<p>源码目录下如下</p>

<p><img src="/images/acts_as_commentable_file_tree.png"></p>

<p>这一步会生成一个rails migration文件和一个叫comment.rb的rails model文件</p>

<p>原理很简单,会在数据库中生成一个叫comments的表
它的字段包括title, comment, commentable_type, commentable_id, user_id等</p>

<p>而生成这两个模版文件的源码如下:</p>

<p>``` ruby lib/generators/comment/comment_generator.rb
require &lsquo;rails/generators/migration&rsquo;</p>

<p>class CommentGenerator &lt; Rails::Generators::Base
  include Rails::Generators::Migration</p>

<p>  def self.source_root</p>

<pre><code>@_acts_as_commentable_source_root ||= File.expand_path("../templates", __FILE__)
</code></pre>

<p>  end</p>

<p>  def self.next_migration_number(path)</p>

<pre><code>Time.now.utc.strftime("%Y%m%d%H%M%S")
</code></pre>

<p>  end</p>

<p>  def create_model_file</p>

<pre><code>template "comment.rb", "app/models/comment.rb"
migration_template "create_comments.rb", "db/migrate/create_comments.rb"
</code></pre>

<p>  end
end
```</p>

<p>这是使用rails generation功能实现的</p>

<!-- more -->


<p>还可以查看其他gem的实现方式</p>

<p><a href="https://github.com/LTe/acts-as-messageable/blob/master/lib/generators/acts-as-messageable/migration/migration_generator.rb">acts_as_messageable</a></p>

<p>更详细的可参考<a href="http://guides.rubyonrails.org/generators.html">rails generation</a></p>

<h3>如何使用</h3>

<p>``` ruby
class Post &lt; ActiveRecord::Base
  acts_as_commentable
end</p>

<p>commentable = Post.create
commentable.comments.create(:title => &ldquo;First comment.&rdquo;, :comment => &ldquo;This is the first comment.&rdquo;)
```</p>

<h4>分析</h4>

<p>如果不使用gem来写评论，一般我们会在model上写has_many comments这样的东西，而acts_as_commentable这个gem它也是要实现这个的，只是它进行包装</p>

<p>关键在<code>acts_as_commentable</code>这一行</p>

<p>``` ruby lib/commentable_method.rb
require &lsquo;active_record&rsquo;</p>

<h1>ActsAsCommentable</h1>

<p>module Juixe
  module Acts #:nodoc:</p>

<pre><code>module Commentable #:nodoc:

  def self.included(base)
    # active_record类会extend ClassMethods模块
    base.extend ClassMethods  
  end

  module ClassMethods
    # 由active_record继承的model都有acts_as_commentable这个方法
    def acts_as_commentable(options={})
      # 多态
      has_many :comments, {:as =&gt; :commentable, :dependent =&gt; :destroy}.merge(options)
      # 具体model实例方法
      include Juixe::Acts::Commentable::InstanceMethods
      # 具体model类的单例方法
      extend Juixe::Acts::Commentable::SingletonMethods
    end
  end
  ...
</code></pre>

<p>ActiveRecord::Base.send(:include, Juixe::Acts::Commentable)
```</p>

<p>有这一句<code>ActiveRecord::Base.send(:include, Juixe::Acts::Commentable)</code>只要任何继承ActiveRecord::Base的model都可以使用<code>acts_as_commentable</code> 它是一个classMethods</p>

<p>现在我们来分析源码commentable_methods.rb</p>

<p><code>ruby
has_many :comments, {:as =&gt; :commentable, :dependent =&gt; :destroy}.merge(options)
include Juixe::Acts::Commentable::InstanceMethods
extend Juixe::Acts::Commentable::SingletonMethods
</code></p>

<p>第一行是一个activemodel relationship表示model使用多态的comment
<code>Juixe::Acts::Commentable::SingletonMethods</code>是类的单例方法,下面的方法可以用Post.find_comments_by_user来调用,例如
Book.find_comments_for(Book.last)</p>

<p>``` ruby</p>

<h1>This module contains class methods</h1>

<p>module SingletonMethods
  # Helper method to lookup for comments for a given object.
  # This method is equivalent to obj.comments.
  # 找一个对象的所有comments
  def find_comments_for(obj)</p>

<pre><code># 返回类似Topic, Article这样的字符串
commentable = self.base_class.name
# find_comments_for_commentable是Comment.rb通过include ActsAsCommentable::Comment引入进来的,它是一个类方法
Comment.find_comments_for_commentable(commentable, obj.id)
</code></pre>

<p>  end</p>

<p>  # Helper class method to lookup comments for
  # the mixin commentable type written by a given user.<br/>
  # This method is NOT equivalent to Comment.find_comments_for_user
  # 通过创建者来找comments
  def find_comments_by_user(user)</p>

<pre><code>commentable = self.base_class.name
Comment.where(["user_id = ? and commentable_type = ?", user.id, commentable]).order("created_at DESC")
</code></pre>

<p>  end
end
```</p>

<p>Juixe::Acts::Commentable::InstanceMethods是实例方法
可以通过类似这样的方式来调用实例方法
<code>Book.last.add_comment Comment.create(comment: "second comment")</code></p>

<p>接下来我们来看看comment.rb这边</p>

<p>它总要来个belongs_to吧</p>

<p>``` ruby comment.rb
class Comment &lt; ActiveRecord::Base</p>

<p>  # 引入一些Comment可以使用的方法
  include ActsAsCommentable::Comment</p>

<p>  belongs_to :commentable, :polymorphic => true</p>

<p>  default_scope :order => &lsquo;created_at ASC&rsquo;</p>

<p>  # NOTE: install the acts_as_votable plugin if you
  # want user to vote on the quality of comments.
  #acts_as_voteable</p>

<p>  # NOTE: Comments belong to a user
  belongs_to :user
end
```</p>

<p><code>belongs_to :commentable, :polymorphic =&gt; true</code>这就是原理
然而<code>include ActsAsCommentable::Comment</code>这个会做什么呢</p>

<p>接上来往下看</p>

<p>``` ruby lib/comment_method.rb
module ActsAsCommentable
  # including this module into your Comment model will give you finders and named scopes
  # useful for working with Comments.
  # The named scopes are:
  #   in_order: Returns comments in the order they were created (created_at ASC).
  #   recent: Returns comments by how recently they were created (created_at DESC).
  #   limit(N): Return no more than N comments.
  module Comment</p>

<pre><code>def self.included(comment_model)
  # 引入的是类方法
  comment_model.extend Finders
  # 引入一些scope
  comment_model.scope :in_order, comment_model.order('created_at ASC')
  comment_model.scope :recent,   comment_model.order('created_at DESC')
end

# 下面都是Comment model能使用的类方法
module Finders
  # Helper class method to lookup all comments assigned
  # to all commentable types for a given user.
  # 通过user来找所有comments
  def find_comments_by_user(user)
    where(["user_id = ?", user.id]).order("created_at DESC")
  end

  # Helper class method to look up all comments for 
  # commentable class name and commentable id.
  # 一个简单的where语句
  def find_comments_for_commentable(commentable_str, commentable_id)
    where(["commentable_type = ? and commentable_id = ?", commentable_str, commentable_id]).order("created_at DESC")
  end

  # Helper class method to look up a commentable object
  # given the commentable class name and id 
  # 找到使用评论的对象
  def find_commentable(commentable_str, commentable_id)
    # 返回类自身
    model = commentable_str.constantize
    model.respond_to?(:find_comments_for) ? model.find(commentable_id) : nil
  end
end
</code></pre>

<p>  end
end
```</p>

<p>可以用Comment.find_comments_by_user的方式来调用</p>

<h3>总结</h3>

<p>它的源码并不复杂，我们通过它并不是要写出跟它一样或类似的gem来，只是可以让我们明白一个道理,代码的重用与组织, 就像在Post.rb里写上acts_as_commentable就可以创建评论了,很方便,还有,通过学习这个gem我们可以学习它是如何设计数据库的</p>

<p>类似的gem还有</p>

<ul>
<li><a href="https://github.com/tcocca/acts_as_follower">acts_as_follower</a></li>
<li><a href="https://github.com/LTe/acts-as-messageable">acts-as-messageable</a></li>
<li><a href="https://github.com/mbleigh/acts-as-taggable-on">acts-as-taggable-on</a></li>
<li><a href="https://github.com/goncalossilva/acts_as_paranoid">acts_as_paranoid</a></li>
<li><a href="https://github.com/stefankroes/ancestry">ancestry</a></li>
<li><a href="https://github.com/collectiveidea/awesome_nested_set">awesome_nested_set</a></li>
</ul>


<p>关于acts_as_commentable更详细的用法可查看
<a href="http://juixe.com/techknow/index.php/2006/06/18/acts-as-commentable-plugin/">acts-as-commentable-plugin</a></p>
]]></content>
  </entry>
  
</feed>
