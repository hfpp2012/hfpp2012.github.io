<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: metaprogramming | 小子的博客]]></title>
  <link href="http://yinsigan.github.io/blog/categories/metaprogramming/atom.xml" rel="self"/>
  <link href="http://yinsigan.github.io/"/>
  <updated>2013-12-27T11:30:00+08:00</updated>
  <id>http://yinsigan.github.io/</id>
  <author>
    <name><![CDATA[小子]]></name>
    <email><![CDATA[ganweiliang886@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ruby元编程之block]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/26/rubyyuan-bian-cheng-zhi-block/"/>
    <updated>2013-12-26T17:36:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/26/rubyyuan-bian-cheng-zhi-block</id>
    <content type="html"><![CDATA[<blockquote><blockquote><p>以最简单的方式来理解block</p></blockquote></blockquote>

<h2>block</h2>

<p>我们先看最简单的例子</p>

<p>``` ruby
def awesome_print
  yield
end
awesome_print { puts &ldquo;I&rsquo;m xiaozi&rdquo; }</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>也就是说任何方法你都可以给它传一个block,而且必须是最后一个参数,但是要使用yield去执行这个block</p>

<p>另外,<code>awesome_print { puts 'I'm xiaozi }</code>太难看了,那就</p>

<p><code>ruby
awesome_print do
  puts "I'm xiaozi"
end
</code></p>

<p>漂亮了吧</p>

<p>太简单可不行,总得传参数</p>

<p>``` ruby
def awesome_print name
  yield name
end
awesome_print(&lsquo;xiaozi&rsquo;) do |name|
  puts &ldquo;I&rsquo;m #{name}&rdquo;
end</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>总结一下yield,它就是块的占位符,awesome_print把参数值'xiaozi'传给<code>do ... end</code>块中的name参数,yield占的坑让给了<code>do ... end</code>块,并执行,name参数的值'xiaozi'传给<code>yield name</code>中的name参数</p>

<p>很简单吧!</p>

<p>如何判断一个方法传过来block了?</p>

<p><code>ruby
def awesome_print
  yield if block_given?
  'no block'
end
</code></p>

<p>明白了吗,就是用block_given?</p>

<p>在这里,<code>{ ... }</code>或<code>do ... end</code>跟yield就是成对存在的,传了block,执行时就要用yield</p>

<h2>Proc</h2>

<p>它和block有什么不同呢</p>

<p>``` ruby
say_hello = Proc.new { |name| &ldquo;I&rsquo;m #{name}&rdquo; }
say_hello.call(&lsquo;xiaozi&rsquo;)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>用了关键字Proc.new来创建一个block对象,然后赋给一个变量,最后用call来调用的</p>

<p>原来Proc.new创建的block对象还可以赋给一个变量</p>

<p>很明显,用Proc.new创建的block对象,要由call来执行和调用</p>

<h2>lambda</h2>

<p>``` ruby
say_hello = lambda { |name| &ldquo;I&rsquo;m #{name}&rdquo; }
say_hello.class # => Proc
say_hello.call(&lsquo;xiaozi&rsquo;)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>跟Proc差不多,lambda也创建一个block对象,而且它的类还是Proc</p>

<p>很明显,用lambda创建的block对象,要由call来执行和调用</p>

<h2>block vs lambda vs Proc</h2>

<p>lambda跟Proc在形式上还比较相似,但它们跟<code>do ... end</code>或<code>{ ... }</code>这种形式相差好多</p>

<p>不信?来看下</p>

<h2>&ndash;></h2>

<p>ruby 1.9之后用这个来代替lambda</p>

<p>于是<code>say_hello = lambda { |name| "I'm #{name}" }</code>变成了<code>say_hello = -&gt; { |name| "I'm #{name}" }</code></p>

<p>``` ruby
say_hello = &ndash;> { |name| &ldquo;I&rsquo;m #{name}&rdquo; }
say_hello.class # => Proc
say_hello.call(&lsquo;xiaozi&rsquo;)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>推荐用这种方法</p>

<h2>传多个block对象</h2>

<p>一个block对象作为参数不够,怎么办</p>

<p>``` ruby
def awesome_print(who, where)
  &ldquo;#{who.call} live in #{where.call}&rdquo;
end
who = &ndash;> { &ldquo;xiaozi&rdquo; }
where = &ndash;> {&lsquo;shenzhen&rsquo;}
awesome_print(who, where)</p>

<h1>=></h1>

<p>&ldquo;xiaozi live in shenzhen&rdquo;
```</p>

<p>列好队,用block对象传过去就行了</p>

<h3>&amp; 区别块和块对象</h3>

<p>``` ruby
def awesome_print(&amp;the_proc)
  the_proc
end
my_proc = awesome_print { &ldquo;I&rsquo;m xiaozi&rdquo; }
my_proc.class # => Proc
my_proc.call</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>&amp;这个符号会不会很熟悉呢,对,C语言就有,意思是取地址</p>

<p>难道这里的block跟地址有关系?</p>

<p>在这里&amp;the_proc表示接收的参数的值要是一个<code>do ... end</code>或<code>{ ... }</code>这样的块,而不是由Proc.new或lambda创建的块对象</p>

<p>注意区分<strong>块</strong>和<strong>块对象</strong></p>

<p>很明显<code>do ... end</code>或<code>{ ... }</code>这样的块跟&amp;是一对的</p>

<p>假如把<code>{ .. }</code>换成lambda</p>

<p>``` ruby
def awesome_print(&amp;the_proc)
  the_proc
end
my_proc = lambda { &ldquo;I&rsquo;m xiaozi&rdquo; }
awesome_print(my_proc)</p>

<h1>=></h1>

<p>ArgumentError: wrong number of arguments (1 for 0)
```</p>

<p>出错了吧,看来lambda这样的块对象和&amp;不是一对的</p>

<p>那给lambda生成的block对象前加个&amp;(类似于C语言的取地址)</p>

<p>``` ruby
def awesome_print(&amp;the_proc)
  the_proc
end
my_proc = lambda {  &ldquo;I&rsquo;m xiaozi&rdquo; }</p>

<h1>注意这行</h1>

<p>awesome_print(&amp;my_proc).call</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>果然把lambda前加个&amp;就行</p>

<p>或者这样也行</p>

<p>``` ruby</p>

<h1>注意这行</h1>

<p>def awesome_print(the_proc)
  the_proc
end
my_proc = lambda {  &ldquo;I&rsquo;m xiaozi&rdquo; }
awesome_print(my_proc).call</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>Proc也是跟lambda一样的,不信?你去试试</p>

<p>总结一下,block跟&amp;是一对的,block对象(lambda或Proc)取&amp;才跟&amp;是一对的,block和block对象的区别在于&amp;,block对象取&amp;之后才在形式上跟block一样</p>

<h3>Proc vs lambda的不同之处</h3>

<ol>
<li>return语句</li>
</ol>


<p>``` ruby
def awesome_print(the_proc)
  the_proc.call
end
my_proc = lambda { puts &ldquo;I&rsquo;m xiaozi&rdquo; }
awesome_print(my_proc)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>``` ruby
def another_awesome_print
  my_proc = Proc.new { return &ldquo;I&rsquo;m xiaozi&rdquo; }
  result = my_proc.call
  return result + &lsquo;hello&rsquo;  # unreachable code!
end</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<ol>
<li>参数检查</li>
</ol>


<p>``` ruby
def awesome_print(statu)
  who = &lsquo;xiaozi&rsquo;
  where = &lsquo;shenzhen&rsquo;
  statu.call
end</p>

<p>awesome_print(Proc.new{|who, where, other| &ldquo;#{who} live in #{where} #{other.class}&rdquo;})</p>

<h1>=></h1>

<p>&ldquo; live in  NilClass&rdquo;</p>

<p>awesome_print(lambda{|who, where, other| &ldquo;#{who} live in #{where} #{other.class}&rdquo;})</p>

<h1>=></h1>

<p>ArgumentError: wrong number of arguments (0 for 3)
```</p>

<h2>DSL</h2>
]]></content>
  </entry>
  
</feed>
