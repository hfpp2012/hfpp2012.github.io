<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: metaprogramming | 小子的博客]]></title>
  <link href="http://yinsigan.github.io/blog/categories/metaprogramming/atom.xml" rel="self"/>
  <link href="http://yinsigan.github.io/"/>
  <updated>2013-12-27T10:40:32+08:00</updated>
  <id>http://yinsigan.github.io/</id>
  <author>
    <name><![CDATA[小子]]></name>
    <email><![CDATA[ganweiliang886@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ruby元编程之block]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/26/rubyyuan-bian-cheng-zhi-block/"/>
    <updated>2013-12-26T17:36:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/26/rubyyuan-bian-cheng-zhi-block</id>
    <content type="html"><![CDATA[<blockquote><blockquote><p>最简单的方式来用block</p></blockquote></blockquote>

<h2>block</h2>

<p>我们先看最简单的例子</p>

<p>``` ruby
def awesome_print
  yield
end
awesome_print { puts &ldquo;I&rsquo;m xiaozi&rdquo; }</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>也就是说任何方法你都可以给它传一个block,但是要使用yield去执行这个block</p>

<p>另外,<code>awesome_print { puts 'I'm xiaozi }</code>太难看了,那就</p>

<p><code>ruby
awesome_print do
  puts "I'm xiaozi"
end
</code></p>

<p>漂亮了吧</p>

<p>太简单可不行,总得传参数</p>

<p>``` ruby
def awesome_print name
  yield name
end
awesome_print(&lsquo;xiaozi&rsquo;) do |name|
  puts &ldquo;I&rsquo;m #{name}&rdquo;
end</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>总结一下yield,它就是块的占位符,awesome_print把参数值'xiaozi'传给<code>do ... end</code>块中的name参数,yield占的坑让给了<code>do ... end</code>块,并执行,name参数的值'xiaozi'传给<code>yield name</code>中的name参数</p>

<p>很简单吧!</p>

<p>上文说了任何方法都可以传入一个block,那怎么判断传block了没,因为有时候要根据有没有传block来定制一些业务</p>

<p><code>ruby
def awesome_print
  yield if block_given?
  'no block'
end
</code></p>

<p>明白了吗,就是用block_given?</p>

<p>在这里,<code>{ ... }</code>或<code>do ... end</code>跟yield就是成对存在的,传了block,执行时就要用yield</p>

<h2>proc</h2>

<p>它和block有什么不同呢</p>

<p>``` ruby
say_hello = Proc.new { |name| &ldquo;I&rsquo;m #{name}&rdquo; }
say_hello.call(&lsquo;xiaozi&rsquo;)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>用了关键字Proc.new来创建一个block对象,然后赋给一个变量,最后用call来调用的</p>

<p>原来block还可以取个名字的哦</p>

<p>很明显,用Proc.new创建的block对象,要由call来执行和调用</p>

<h2>lambda</h2>

<p>``` ruby
say_hello = lambda { |name| &ldquo;I&rsquo;m #{name}&rdquo; }
say_hello.class # => Proc
say_hello.call(&lsquo;xiaozi&rsquo;)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>跟proc差不多,lambda也创建一个block对象,而且它的类还是Proc</p>

<p>很明显,用lambda创建的block对象,要由call来执行和调用</p>

<h2>block vs lambda vs proc</h2>

<p>lambda跟proc在形式上还比较相似,但它们跟<code>do ... end</code>或<code>{ ... }</code>这种形式相差好多</p>

<p>不信?来看下</p>

<h3>&amp; 块和块对象</h3>

<p>``` ruby
def awesome_print(&amp;the_proc)
  the_proc
end
my_proc = awesome_print { &ldquo;I&rsquo;m xiaozi&rdquo; }
my_proc.class # => Proc
my_proc.call</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>&amp;这个符号会不会很熟悉呢,对,C语言就有,意思是取地址</p>

<p>难道这里的block跟地址有关系?</p>

<p>在这里&amp;the_proc表示接收的参数的值要是一个<code>do ... end</code>或<code>{ ... }</code>这样的块,而不是由Proc.new或lambda创建的块对象</p>

<p>注意区分<strong>块</strong>和<strong>块对象</strong></p>

<p>很明显<code>do ... end</code>或<code>{ ... }</code>这样的块跟&amp;是一对的</p>

<p>假如把<code>{ .. }</code>换成lambda</p>

<p>``` ruby
def awesome_print(&amp;the_proc)
  the_proc
end
my_proc = lambda { &ldquo;I&rsquo;m xiaozi&rdquo; }
awesome_print(my_proc)</p>

<h1>=></h1>

<p>ArgumentError: wrong number of arguments (1 for 0)
```</p>

<p>出错了吧,看来lambda这样的块对象和&amp;不是一对的</p>

<p>那给lambda加个&amp;(类似于C语言的取地址)</p>

<p>好的</p>

<p>``` ruby
def awesome_print(&amp;the_proc)
  the_proc
end</p>

<p>my_proc = lambda {  &ldquo;I&rsquo;m xiaozi&rdquo; }</p>

<h1>注意这行</h1>

<p>awesome_print(&amp;my_proc).call</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>果然把lambda前加个&amp;就行</p>

<p>或者这样也行</p>

<p>``` ruby</p>

<h1>注意这行</h1>

<p>def awesome_print(the_proc)
  the_proc
end</p>

<p>my_proc = lambda {  &ldquo;I&rsquo;m xiaozi&rdquo; }
awesome_print(my_proc).call</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>看来block和block对象的区别在于&amp;,block对象取&amp;之后才在形式上跟block一样</p>

<h3>proc vs lambda return语句</h3>

<p>``` ruby
def awesome_print(the_proc)
  the_proc.call
end
my_proc = lambda { puts &ldquo;I&rsquo;m xiaozi&rdquo; }
awesome_print(my_proc)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>``` ruby
def another_awesome_print
  my_proc = Proc.new { return &ldquo;I&rsquo;m xiaozi&rdquo; }
  result = my_proc.call
  return result + &lsquo;hello&rsquo;  # unreachable code!
end</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<h2>DSL</h2>

<h2>&ndash;></h2>
]]></content>
  </entry>
  
</feed>
