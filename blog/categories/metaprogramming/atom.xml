<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: metaprogramming | 小子的博客]]></title>
  <link href="http://yinsigan.github.io/blog/categories/metaprogramming/atom.xml" rel="self"/>
  <link href="http://yinsigan.github.io/"/>
  <updated>2013-12-26T22:46:35+08:00</updated>
  <id>http://yinsigan.github.io/</id>
  <author>
    <name><![CDATA[小子]]></name>
    <email><![CDATA[ganweiliang886@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ruby元编程之block]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/26/rubyyuan-bian-cheng-zhi-block/"/>
    <updated>2013-12-26T17:36:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/26/rubyyuan-bian-cheng-zhi-block</id>
    <content type="html"><![CDATA[<blockquote><blockquote><p>最简单的方式来用block</p></blockquote></blockquote>

<h2>block</h2>

<p>我们先看最简单的例子</p>

<p>``` ruby
def awesome_print
  yield
end
awesome_print { puts &ldquo;I&rsquo;m xiaozi&rdquo; }</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>也就是说任何方法你都可以给它传一个block,但是要使用yield去执行这个block</p>

<p>另外,<code>awesome_print { puts 'I'm xiaozi }</code>太难看了,那就</p>

<p><code>ruby
awesome_print do
  puts "I'm xiaozi"
end
</code></p>

<p>漂亮了吧</p>

<p>太简单可不行,总得传参数</p>

<p>``` ruby
def awesome_print name
  yield name
end
awesome_print(&lsquo;xiaozi&rsquo;) do |name|
  puts &ldquo;I&rsquo;m #{name}&rdquo;
end</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>总结一下yield,它就是块的占位符,awesome_print把参数值'xiaozi'传给<code>do ... end</code>块中的name参数,yield占的坑让给了<code>do ... end</code>块,并执行,name参数的值'xiaozi'传给<code>yield name</code>中的name参数</p>

<p>很简单吧!</p>

<p>上文说了任何方法都可以传入一个block,那怎么判断传block了没,因为有时候要根据有没有传block来定制一些业务</p>

<p><code>ruby
def awesome_print
  yield if block_given?
  'no block'
end
</code></p>

<p>明白了吗,就是用block_given?</p>

<h2>proc</h2>

<p>它和block有什么不同呢</p>

<p>``` ruby
say_hello = Proc.new { |name| &ldquo;I&rsquo;m #{name}&rdquo; }
say_hello.call(&lsquo;xiaozi&rsquo;)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>用了关键字Proc.new来创建一个block对象,然后赋给一个变量,最后用call来调用的</p>

<p>原来block还可以取个名字的哦</p>

<h2>lambda</h2>

<p>``` ruby
say_hello = lambda { |name| &ldquo;I&rsquo;m #{name}&rdquo; }
say_hello.class # => Proc
say_hello.call(&lsquo;xiaozi&rsquo;)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<h2>&amp;</h2>

<p>``` ruby
def awesome_print(&amp;the_proc)
  the_proc
end
my_proc = awesome_print { |name| &ldquo;I&rsquo;m #{name}&rdquo; }
my_proc.class # => Proc
my_proc.call(&lsquo;xiaozi&rsquo;)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>``` ruby
def awesome_print
  puts &ldquo;I&rsquo;m #{yield}&rdquo;
end
my_proc = proc { &ldquo;xiaozi&rdquo; }
awesome_print(&amp;my_proc)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<h2>proc vs lambda</h2>

<ol>
<li>return</li>
</ol>


<p>``` ruby
def awesome_print(the_proc)
  the_proc.call
end
my_proc = lambda { puts &ldquo;I&rsquo;m xiaozi&rdquo; }
awesome_print(my_proc)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>``` ruby
def another_awesome_print
  my_proc = Proc.new { return &ldquo;I&rsquo;m xiaozi&rdquo; }
  result = my_proc.call
  return result + &lsquo;hello&rsquo;  # unreachable code!
end</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<h2>DSL</h2>

<h2>&ndash;></h2>
]]></content>
  </entry>
  
</feed>
