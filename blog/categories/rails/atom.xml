<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | 小子的博客]]></title>
  <link href="http://yinsigan.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://yinsigan.github.io/"/>
  <updated>2013-12-27T10:43:31+08:00</updated>
  <id>http://yinsigan.github.io/</id>
  <author>
    <name><![CDATA[小子]]></name>
    <email><![CDATA[ganweiliang886@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ruby元编程之block]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/26/rubyyuan-bian-cheng-zhi-block/"/>
    <updated>2013-12-26T17:36:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/26/rubyyuan-bian-cheng-zhi-block</id>
    <content type="html"><![CDATA[<blockquote><blockquote><p>最简单的方式来用block</p></blockquote></blockquote>

<h2>block</h2>

<p>我们先看最简单的例子</p>

<p>``` ruby
def awesome_print
  yield
end
awesome_print { puts &ldquo;I&rsquo;m xiaozi&rdquo; }</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>也就是说任何方法你都可以给它传一个block,但是要使用yield去执行这个block</p>

<p>另外,<code>awesome_print { puts 'I'm xiaozi }</code>太难看了,那就</p>

<p><code>ruby
awesome_print do
  puts "I'm xiaozi"
end
</code></p>

<p>漂亮了吧</p>

<p>太简单可不行,总得传参数</p>

<p>``` ruby
def awesome_print name
  yield name
end
awesome_print(&lsquo;xiaozi&rsquo;) do |name|
  puts &ldquo;I&rsquo;m #{name}&rdquo;
end</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>总结一下yield,它就是块的占位符,awesome_print把参数值'xiaozi'传给<code>do ... end</code>块中的name参数,yield占的坑让给了<code>do ... end</code>块,并执行,name参数的值'xiaozi'传给<code>yield name</code>中的name参数</p>

<p>很简单吧!</p>

<p>上文说了任何方法都可以传入一个block,那怎么判断传block了没,因为有时候要根据有没有传block来定制一些业务</p>

<p><code>ruby
def awesome_print
  yield if block_given?
  'no block'
end
</code></p>

<p>明白了吗,就是用block_given?</p>

<p>在这里,<code>{ ... }</code>或<code>do ... end</code>跟yield就是成对存在的,传了block,执行时就要用yield</p>

<h2>proc</h2>

<p>它和block有什么不同呢</p>

<p>``` ruby
say_hello = Proc.new { |name| &ldquo;I&rsquo;m #{name}&rdquo; }
say_hello.call(&lsquo;xiaozi&rsquo;)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>用了关键字Proc.new来创建一个block对象,然后赋给一个变量,最后用call来调用的</p>

<p>原来block还可以取个名字的哦</p>

<p>很明显,用Proc.new创建的block对象,要由call来执行和调用</p>

<h2>lambda</h2>

<p>``` ruby
say_hello = lambda { |name| &ldquo;I&rsquo;m #{name}&rdquo; }
say_hello.class # => Proc
say_hello.call(&lsquo;xiaozi&rsquo;)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>跟proc差不多,lambda也创建一个block对象,而且它的类还是Proc</p>

<p>很明显,用lambda创建的block对象,要由call来执行和调用</p>

<h2>block vs lambda vs proc</h2>

<p>lambda跟proc在形式上还比较相似,但它们跟<code>do ... end</code>或<code>{ ... }</code>这种形式相差好多</p>

<p>不信?来看下</p>

<h3>&amp; 块和块对象</h3>

<p>``` ruby
def awesome_print(&amp;the_proc)
  the_proc
end
my_proc = awesome_print { &ldquo;I&rsquo;m xiaozi&rdquo; }
my_proc.class # => Proc
my_proc.call</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>&amp;这个符号会不会很熟悉呢,对,C语言就有,意思是取地址</p>

<p>难道这里的block跟地址有关系?</p>

<p>在这里&amp;the_proc表示接收的参数的值要是一个<code>do ... end</code>或<code>{ ... }</code>这样的块,而不是由Proc.new或lambda创建的块对象</p>

<p>注意区分<strong>块</strong>和<strong>块对象</strong></p>

<p>很明显<code>do ... end</code>或<code>{ ... }</code>这样的块跟&amp;是一对的</p>

<p>假如把<code>{ .. }</code>换成lambda</p>

<p>``` ruby
def awesome_print(&amp;the_proc)
  the_proc
end
my_proc = lambda { &ldquo;I&rsquo;m xiaozi&rdquo; }
awesome_print(my_proc)</p>

<h1>=></h1>

<p>ArgumentError: wrong number of arguments (1 for 0)
```</p>

<p>出错了吧,看来lambda这样的块对象和&amp;不是一对的</p>

<p>那给lambda加个&amp;(类似于C语言的取地址)</p>

<p>好的</p>

<p>``` ruby
def awesome_print(&amp;the_proc)
  the_proc
end</p>

<p>my_proc = lambda {  &ldquo;I&rsquo;m xiaozi&rdquo; }</p>

<h1>注意这行</h1>

<p>awesome_print(&amp;my_proc).call</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>果然把lambda前加个&amp;就行</p>

<p>或者这样也行</p>

<p>``` ruby</p>

<h1>注意这行</h1>

<p>def awesome_print(the_proc)
  the_proc
end</p>

<p>my_proc = lambda {  &ldquo;I&rsquo;m xiaozi&rdquo; }
awesome_print(my_proc).call</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>Proc也是跟lambda一样的,不信?你去试试</p>

<p>总结一下,block跟&amp;是一对的,block对象(lambda或proc)取&amp;才跟&amp;是一对的,block和block对象的区别在于&amp;,block对象取&amp;之后才在形式上跟block一样</p>

<h3>proc vs lambda return语句</h3>

<p>``` ruby
def awesome_print(the_proc)
  the_proc.call
end
my_proc = lambda { puts &ldquo;I&rsquo;m xiaozi&rdquo; }
awesome_print(my_proc)</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<p>``` ruby
def another_awesome_print
  my_proc = Proc.new { return &ldquo;I&rsquo;m xiaozi&rdquo; }
  result = my_proc.call
  return result + &lsquo;hello&rsquo;  # unreachable code!
end</p>

<h1>=></h1>

<p>I&rsquo;m xiaozi
```</p>

<h2>DSL</h2>

<h2>&ndash;></h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[acts_as_paranoid源码分析]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/20/acts-as-paranoidyuan-ma-fen-xi/"/>
    <updated>2013-12-20T21:57:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/20/acts-as-paranoidyuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<ul>
<li><a href="https://github.com/goncalossilva/acts_as_paranoid">acts_as_paranoid</a></li>
</ul>


<p>它的作用就是假删除,在实际中还是会很有用的。有一天,客户说,她刚才误删了一个东西,要你把它找回来,这个时候它就派上用场了。</p>

<p>回收站或者垃圾箱也是假删除的典型应用.假如一个邮箱系统中,用户把邮件删除掉,这个时候这些邮件并没有被彻底删除掉,它其实是先到了垃圾箱中,如果要彻底删除它,请到垃圾箱那里再删一次吧</p>

<p>其实它实际上不删除数据中的数据,只不过是隐藏起来而已,只要让用户看不到,它就等于删除了,实际上,要还原的话修改一下数据库就可以回来了</p>

<!-- more -->


<p>它实现的原理很简单,只不过是用一个标志来实现隐藏数据,在数据表中加一个字段,把它的值改一下,它就删除了(隐藏),修改回来,它又出现了</p>

<p>它的目的就是保护数据的安全,让用户能在误操作的情况下也能恢复数据。但是缺点也很明显,由于不是真正的删除,数据库中仍然保留着那条数据,数据库会越来越庞大,垃圾的信息也是越来越多</p>

<p>默认情况下用<strong>&ldquo;deleted_at&rdquo;</strong>这个字段,用一个参数<strong>column</strong>来指定,它可以有三种类型boolean, string, time,这三个类型用<strong>column_type</strong>参数来指定</p>

<p>boolean:布尔型,被删除时值为true</p>

<p>string:字符串型,被删除时值为"deleted",这个值可以用deleted_value参数来指定</p>

<p>time:时间型,被删除时值为当前时间(删除操作的时间)</p>

<p>以上三个类型未删除时值都为NULL(nil)。建议使用time类型</p>

<p>使用举例如下:</p>

<p><code>ruby
class School &lt; ActiveRecord::Base
  acts_as_paranoid :column_type =&gt; :boolean
  或
  acts_as_paranoid :column =&gt; "is_deleted", :column_type =&gt; :string, :deleted_value =&gt; "deleted"
  ...
end
</code></p>

<p>分析该gem的源码可以懂得下面的知识</p>

<ol>
<li>attr_protected的使用</li>
<li>写一个callback</li>
<li>included_modules的用法</li>
<li>scoped unscoped的用法</li>
<li>activerecord/Reflection的用法</li>
<li>自己写一个validator</li>
<li>class_attribute的用法</li>
<li>activerecord/relation中klass的用法</li>
<li>alias_method_chain的用法</li>
<li>method_defined?的用法</li>
</ol>


<h2>代码分析</h2>

<h3>代码结构</h3>

<p><code>
├── lib
│   ├── acts_as_paranoid
│   │   ├── associations.rb   关于关联模型的
│   │   ├── core.rb   核心文件
│   │   ├── relation.rb     关于relation的操作
│   │   └── validations.rb   一个验证方法
│   └── acts_as_paranoid.rb  主程序
</code></p>

<h3>Filtering(过滤)</h3>

<p><code>ruby
School.only_deleted # 找到所有已经假删除的数据
School.with_deleted # 找到所有数据(不管有没有假删除的)
</code></p>

<p><img src="/images/acts_as_paranoid/delete_record.png"></p>

<h4>only_deleted</h4>

<p>现在我们执行School.only_deleted来看看有什么效果</p>

<p><code>
School Load (0.8ms)  SELECT `schools`.* FROM `schools` WHERE (schools.deleted_at IS NOT NULL)
</code></p>

<p>如果我们自己写only_deleted的实现代码可能会写成这样</p>

<p><code>ruby
deleted_at = options[:column]
School.where("#{deleted_at} IS NOT NULL")
</code></p>

<p>其实acts_as_paranoid的源码也差不多</p>

<p>``` ruby acts_as_paranoid
def only_deleted
  # 判断是不是string类型
  if string_type_with_deleted_value?</p>

<pre><code>without_paranoid_default_scope.where("#{paranoid_column_reference} IS ?", paranoid_configuration[:deleted_value])
</code></pre>

<p>  else</p>

<pre><code>without_paranoid_default_scope.where("#{paranoid_column_reference} IS NOT ?", nil)
</code></pre>

<p>  end
end
```</p>

<p>由于string这种类型的不能判断是不是等于NULL,而是要看是不是等于一个值(默认为"deleted", 由":deleted_value"这个参数决定)</p>

<p>于是</p>

<p>``` ruby 伪代码
def string_type_with_deleted_value?
  if options[:column_type] == :string</p>

<pre><code>return true
</code></pre>

<p>  end
  false
end
```</p>

<p>acts_as_paranoid的代码为</p>

<p><code>ruby
def string_type_with_deleted_value?
  paranoid_column_type == :string &amp;&amp; !paranoid_configuration[:deleted_value].nil?
end
</code></p>

<p>without_paranoid_default_scope是?</p>

<p>``` ruby
def without_paranoid_default_scope
  scope = self.scoped.with_default_scope
  scope.where_values.delete(paranoid_default_scope_sql)</p>

<p>  scope
end
```</p>

<p>如果不是一个gem它不要也行,我们写成School.where&hellip;照样目的能达到</p>

<p>既然做成了一个gem,每个用acts_as_paranoid的model都默认加了一个default_scope,一般情况下,假删除的数据是查不到的,所以要隐藏起来,with_deleted会使用,或者你执行School.all也会使用的</p>

<p>default_scope的效果大约是这样的</p>

<p><code>ruby
School.where("deleted_at IS NULL")
</code></p>

<p>所以without_paranoid_default_scope的作用就是去掉这个效果</p>

<p>其实要去掉只要用unscoped就可以了,但acts_as_paranoid把with_deleted,和only_deleted做成了scope(activerecord/relations)的效果</p>

<p><code>ruby
School.scoped.with_default_scope.where_values
=&gt; ["`schools`.`deleted_at` IS NULL"]
School.paranoid_default_scope_sql
=&gt; "`schools`.`deleted_at` IS NULL"
</code></p>

<p>so</p>

<p><code>ruby
School.with_deleted.where(...)
School.where(...).with_deleted
</code></p>

<p>而acts_as_paranoid的default_scope是这样的</p>

<p>``` ruby
default_scope { where(paranoid_default_scope_sql) }</p>

<p>def paranoid_default_scope_sql
  if string_type_with_deleted_value?</p>

<pre><code>self.scoped.table[paranoid_column].eq(nil).
  or(self.scoped.table[paranoid_column].not_eq(paranoid_configuration[:deleted_value])).
  to_sql
</code></pre>

<p>  else</p>

<pre><code>self.scoped.table[paranoid_column].eq(nil).to_sql
</code></pre>

<p>  end
end
```</p>

<p>scoped.table不懂的看<a href="https://github.com/rails/arel">arel-table</a></p>

<p>paranoid_column_reference是?</p>

<p><code>ruby
self.paranoid_column_reference = "#{self.table_name}.#{paranoid_configuration[:column]}"
</code></p>

<p>paranoid_configuration是?</p>

<p>``` ruby
raise ArgumentError, &ldquo;Hash expected, got #{options.class.name}&rdquo; if not options.is_a?(Hash) and not options.empty?
class_attribute :paranoid_configuration, :paranoid_column_reference</p>

<p>self.paranoid_configuration = { :column => &ldquo;deleted_at&rdquo;, :column_type => &ldquo;time&rdquo;, :recover_dependent_associations => true, :dependent_recovery_window => 2.minutes }
self.paranoid_configuration.merge!({ :deleted_value => &ldquo;deleted&rdquo; }) if options[:column_type] == &ldquo;string&rdquo;
self.paranoid_configuration.merge!(options) # user options</p>

<p>raise ArgumentError, &ldquo;&lsquo;time&rsquo;, &lsquo;boolean&rsquo; or &lsquo;string&rsquo; expected for :column_type option, got #{paranoid_configuration[:column_type]}&rdquo; unless [&lsquo;time&rsquo;, &lsquo;boolean&rsquo;, &lsquo;string&rsquo;].include? paranoid_configuration[:column_type]</p>

<p>self.paranoid_column_reference = &ldquo;#{self.table_name}.#{paranoid_configuration[:column]}&rdquo;</p>

<p>return if paranoid?
```</p>

<p>paranoid_configuration是个关于配置的,我们传入的column和column_type等都会存到这个hash里面</p>

<p><a href="http://apidock.com/rails/Class/class_attribute">class_attribute</a>这个和<a href="http://apidock.com/rails/Class/cattr_accessor">cattr_accessor</a>可以作这个比较</p>

<p>class_attribute和cattr_accessor都包含read(get)和write(set),但是class_attribute只属于类,子类都不能共享,而cattr_accessor是类和子类和实例共享的,具体的看文档就知道了</p>

<p>merge和merge!的区别是后者会改变原来的hash</p>

<p>merge和update差不多,如果有相同的key,会替换原来的值,没有的会添加</p>

<p><code>ruby
def paranoid?
  self.included_modules.include?(ActsAsParanoid::Core)
end
</code></p>

<p>included_modules是类方法,返回所以它include的module,用这个就可以判断是否有加载过ActsAsParanoid,加载过的就可以不用再次加载了</p>

<p>至此only_deleted已经解释完了</p>

<h4>with_deleted</h4>

<p>来看下with_deleted,它就是无论有没有被假删除,都读出来</p>

<p><code>ruby
def with_deleted
  without_paranoid_default_scope
end
</code></p>

<p>without_paranoid_default_scope上面已经解释过</p>

<h4>deleted_after_time &amp; deleted_before_time &amp; deleted_inside_time_window</h4>

<p>deleted_after_time: 在一个时间之后假删除的记录</p>

<p>deleted_before_time: 在一个时间之前假删除的记录</p>

<p>deleted_inside_time_window: 在一定时间内假删除的记录</p>

<p><img src="/images/acts_as_paranoid/deleted_time.png"></p>

<p>实现方法也很简单</p>

<p>``` ruby
if paranoid_configuration[:column_type] == &lsquo;time&rsquo;
  scope :deleted_inside_time_window, lambda {|time, window|</p>

<pre><code>deleted_after_time((time - window)).deleted_before_time((time + window))
</code></pre>

<p>  }</p>

<p>  scope :deleted_after_time, lambda  { |time| where(&ldquo;#{paranoid_column} > ?&rdquo;, time) }
  scope :deleted_before_time, lambda { |time| where(&ldquo;#{paranoid_column} &lt; ?&rdquo;, time) }
end
```</p>

<h3>Real deletion(真删除)</h3>

<p>实际上我们执行School.first.destroy时是假删除而已,只是把字段(deleted_at)的值改了一下,要想真正删除还是要再执行一次destroy</p>

<p><img src="/images/acts_as_paranoid/destroy_record.png"></p>

<p>如果不想执行两次destroy,那就用destroy!一次搞定</p>

<h4>destroy 单条记录假删除</h4>

<p>我们来看一下它实现的代码,它把本来的destroy方法给重写了</p>

<p>``` ruby
def destroy
  # 还没有被假删除的情况下
  if !deleted?</p>

<pre><code>with_transaction_returning_status do
  run_callbacks :destroy do
    # Handle composite keys, otherwise we would just use `self.class.primary_key.to_sym =&gt; self.id`.
    self.class.delete_all(Hash[[Array(self.class.primary_key), Array(self.id)].transpose]) if persisted?
    self.paranoid_value = self.class.delete_now_value
    self
  end
end
</code></pre>

<p>  else</p>

<pre><code>destroy!
</code></pre>

<p>  end
end
```</p>

<p>读懂上面的代码必须先弄懂deleted?</p>

<p>``` ruby</p>

<h1>通过deleted_at的值来检验记录是否被删除</h1>

<p>def deleted?
  !(paranoid_value.nil? ||</p>

<pre><code>(self.class.string_type_with_deleted_value? &amp;&amp; paranoid_value != self.class.delete_now_value))
</code></pre>

<p>end</p>

<h1>destroyed?是rails提供的,现在的效果跟:deleted?一样</h1>

<p>alias_method :destroyed?, :deleted?</p>

<h1>判断一条记录是否是常归存在</h1>

<p>def persisted?
  !(new_record? || @destroyed)
end</p>

<h1>这个方法是rails提供的,destroyed?会利用到@destroyed</h1>

<p>def destroyed?
  @destroyed
end
```</p>

<p>总而言之,deleted?是判断是不是被假删除</p>

<p><a href="http://apidock.com/rails/ActiveRecord/Transactions/with_transaction_returning_status">with_transaction_returning_status</a>是ActiveRecord::Base提供的方法,作用就是运行一个transaction,然后再返回一个状态值</p>

<p>``` ruby with_transaction_returning_status的源码
def with_transaction_returning_status
  status = nil
  self.class.transaction do</p>

<pre><code>add_to_transaction
status = yield
raise ActiveRecord::Rollback unless status
</code></pre>

<p>  end
  status
end
```</p>

<p>现在我们知道了,原来destroy?是包在一个transaction里的</p>

<p>接下来,run_callbacks :destroy是?</p>

<p>关于run_callbacks可以看<a href="http://api.rubyonrails.org/classes/ActiveSupport/Callbacks.html">callback</a></p>

<p>运行run_callbacks :destroy的时候如果有定义before_destroy和after_destroy的话,会运行它们</p>

<p>run_callbacks :destroy里面的内容才是真正的删除操作</p>

<p><code>ruby
self.class.delete_all(Hash[[Array(self.class.primary_key), Array(self.id)].transpose]) if persisted?
self.paranoid_value = self.class.delete_now_value
self
</code></p>

<p>先来看下self.class.delete_all!</p>

<p><code>ruby
def delete_all(conditions = nil)
  # update_all相比于update_attributes来说后面可以加查询条件conditions,还有update_all是类方法
  # 如果不加条件(conditions),update_all会修改所有记录的deleted_at值
  update_all ["#{paranoid_configuration[:column]} = ?", delete_now_value], conditions
end
</code></p>

<p>delete_now_value它的作用就是把deleted_all改为当前时间(如果deleted_at为time类型)或True(如果delete_at为boolean类型)或一个值(如果delete_at为string类型)</p>

<p>so</p>

<p><code>ruby
def delete_now_value
  case paranoid_configuration[:column_type]
  when "time" then Time.now
  when "boolean" then true
  when "string" then paranoid_configuration[:deleted_value]
  end
end
</code></p>

<h4>destroy! 单条记录真删除</h4>

<p>实现的代码跟destroy差不多,它不改deleted_at的值,直接删除数据</p>

<p>``` ruby
def destroy!
  with_transaction_returning_status do</p>

<pre><code>run_callbacks :destroy do
  destroy_dependent_associations!
  # Handle composite keys, otherwise we would just use `self.class.primary_key.to_sym =&gt; self.id`.
  self.class.delete_all!(Hash[[Array(self.class.primary_key), Array(self.id)].transpose]) if persisted?
  self.paranoid_value = self.class.delete_now_value
  freeze
end
</code></pre>

<p>  end
end
```</p>

<p>destroy_dependent_associations!这个跟关联删除(dependent: destroy)有关的,也说是说假如school has_many squads,删除一条school的时候会先把所有squads先删除掉,这个留待下文详述</p>

<p>来看delete_all!方法</p>

<p><code>ruby
def delete_all!(conditions = nil)
  without_paranoid_default_scope.delete_all!(conditions)
end
</code></p>

<p>without_paranoid_default_scope是不带default_scope的scoped查询,也就是去掉那个默认的查询(不含假删除过的记录),上文有说过</p>

<p>without_paranoid_default_scope.delete_all!这个delete_all!可不是类方法,而是scoped中的方法,因为without_paranoid_default_scope是一个scoped(可以看without_paranoid_default_scope的定义)</p>

<p>在哪里找到delete_all!呢?</p>

<p>由于scoped是定义在ActiveRecord/Relation中的,lib/acts_as_paranoid.rb有一条语句</p>

<p>``` ruby</p>

<h1>Override ActiveRecord::Relation&rsquo;s behavior</h1>

<p>ActiveRecord::Relation.send :include, ActsAsParanoid::Relation
```</p>

<p>so</p>

<p>``` ruby lib/acts_as_paranoid/relation.rb
module ActsAsParanoid
  module Relation</p>

<pre><code>def self.included(base)
  # 实例方法
  base.class_eval do
    ....
    alias_method :orig_delete_all, :delete_all
    def delete_all!(conditions = nil)
      if conditions
        # 没有条件就会去调用orig_delete_all
        where(conditions).delete_all!
      else
        orig_delete_all
      end
    end
    ...
  end
end
</code></pre>

<p>  end
end
```</p>

<p>其实把那个查询条件交给where,再用orig_delete_all删除</p>

<p>上面的例子前后已经出现过两次alias_method了,我们来总结一下</p>

<p>在上面的例子中alias_method会把:delete_all(这个时候的delete_all是rails默认提供的那个)的代码复制一份给orig_delete_all,然后把delete_all重写一次,以后调用都会用重写过的,被重写那个(rails提供)就变成了orig_delete_all</p>

<p>freeze的作用是它那个记录锁住,已经被删除了那就不能修改,虽然存到变量之后还能读取</p>

<h4>delete_all 多条记录假删除</h4>

<p>多条记录真删除的那个方法就lib/acts_as_paranoid/relation.rb中的delete_all!方法</p>

<p>``` ruby
def delete_all(conditions = nil)
  # 判断是否有加载过acts_as_paranoid,对于没有使用这个gem的会使用rails提供的delete_all!(真删除)来删除
  if paranoid?</p>

<pre><code>update_all(paranoid_deletion_attributes, conditions)
</code></pre>

<p>  else</p>

<pre><code>delete_all!(conditions)
</code></pre>

<p>  end
end</p>

<h1>传入数组</h1>

<p>def destroy!(id_or_array)
  where(primary_key => id_or_array).orig_delete_all
end
```</p>

<h3>Associations 关联关系</h3>

<p>有一种情况是这样的,我们可能在school model里有这样的东西<code>has_many :squads, :dependent =&gt; :destroy</code>(班级),假如你删除了一条school,那squads怎么办呢</p>

<p>这种情况下squad model分为两种可能: 1:要么没使用acts_as_paranoid 2:要么使用acts_as_paranoid</p>

<p>对于没使用acts_as_paranoid的squad model那就很简单,本来该怎么着就怎么着</p>

<p>对于使用acts_as_paranoid的squad model那就是<strong>连带假删除</strong></p>

<h4>连带假删除</h4>

<p>``` ruby
class School &lt; ActiveRecord::Base
  has_many :squads, :dependent => :destroy
  acts_as_paranoid
end</p>

<p>class squad &lt; ActiveRecord::Base
  belongs_to :school
  acts_as_paranoid
end
```
<img src="/images/acts_as_paranoid/dependent_destroy.png"></p>

<p>其实关于acts_as_paranoid的假删除上面已经说过它的代码了</p>

<p>就是那个destroy方法,按照rails的机制,当设置:dependent => :destroy,父类执行destroy方法,子类也是会执行自己的destroy的</p>

<p>也就是squad model会执行acts_as_paranoid重写的destroy方法,因为squad model使用了acts_as_paranoid</p>

<p>所以它(squad)使用了跟父类(school)同样的destroy方法,上文说过,这里就不做多解释了</p>

<h4>连带真删除</h4>

<p>上文说过,真删除使用的是destroy!方法,在父类(school)使用destroy!,子类(squad)并没有执行任何方法,但它又需要把属于school的所有squads(班级)全部删除</p>

<p>所以在destroy!需要处理子类(把它删除掉)</p>

<p>``` ruby
def destroy!
  with_transaction_returning_status do</p>

<pre><code>run_callbacks :destroy do
  destroy_dependent_associations!
  ...
end
</code></pre>

<p>  end
end
```</p>

<p>destroy_dependent_associations这个方法才是处理子类的关键</p>

<p>``` ruby
def destroy_dependent_associations!
  self.class.dependent_associations.each do |reflection|</p>

<pre><code># 这句也很关键,判断子类有没有使用acts_as_paranoid,
# 没有的话就没必要进行下去,应该根本没有destroy!方法,而rails默认就会删除的
next unless reflection.klass.paranoid?

scope = reflection.klass.only_deleted

# Merge in the association's scope
scope = scope.merge(association(reflection.name).association_scope)

scope.each do |object|
  # 这句才是真正的删除
  object.destroy!
end
</code></pre>

<p>  end
end
```</p>

<p>要真删除school,总得知道它有哪些子类belongs_to school吧,所以这个destroy_dependent_associations方法的前半部分都在找school究终has_many了哪些model,最后一句object.destroy!才是真正的删除</p>

<p>dependent_associations是?</p>

<p><code>ruby
def dependent_associations
  # 过滤父类中has_many dependent等于:destroy或:delete_all的association
  self.reflect_on_all_associations.select {|a| [:destroy, :delete_all].include?(a.options[:dependent]) }
end
</code></p>

<p><a href="http://api.rubyonrails.org/classes/ActiveRecord/Reflection/ClassMethods.html">reflect_on_all_associations</a>是rails提供的方法</p>

<p>其实reflect_on_all_associations就是返回model所有包含的associations(关联关系的数组),而reflect_on_association可以取得某个特定的关联关系,例如School.reflect_on_association(:squads)</p>

<p><img src="/images/acts_as_paranoid/reflect_on_association.png"></p>

<p>association是activerecord/associations.rb提供的</p>

<p>``` ruby
def association(name) #:nodoc:
  association = association_instance_get(name)</p>

<p>  if association.nil?</p>

<pre><code>reflection  = self.class.reflect_on_association(name)
association = reflection.association_class.new(self, reflection)
association_instance_set(name, association)
</code></pre>

<p>  end</p>

<p>  association
end
```</p>

<p>其实它内部主要也是在用reflect_on_association,它用于某个实例,找到这个实例相关联的squads,然后交给下面的代码删除</p>

<h4>belongs_to的参数with_deleted</h4>

<p>把一个school假删除之后,它包含的squads也被假删除了,但是执行squad.school来查找school的时候会找不到,因为它使用了default_scope,那个default_scope本来就不查假删除的数据的</p>

<p><img src="/images/acts_as_paranoid/belongs_to_with_deleted.png"></p>

<p>而acts_as_paranoid提供了一个方式(:with_deleted => true)解决这个问题</p>

<p>看下面的代码</p>

<p><code>ruby
class Squad &lt; ActiveRecord::Base
  belongs_to :deleted_school, :class_name =&gt; 'School', :foreign_key =&gt; "school_id", :with_deleted =&gt; true
end
</code></p>

<p>当执行squad.deleted_school就可以查到那条假删除的school数据了</p>

<p><img src="/images/acts_as_paranoid/belongs_to_search.png"></p>

<p>其实那个:with_deleted => true会破掉default_scope</p>

<p>它的源码定义在lib/acts_as_paranoid/associations.rb文件</p>

<p>在acts_as_paranoid.rb主程序文件里引入它</p>

<p>``` ruby</p>

<h1>Extend ActiveRecord::Base with paranoid associations</h1>

<p>ActiveRecord::Base.send :include, ActsAsParanoid::Associations
```</p>

<p>``` ruby
module ActsAsParanoid
  module Associations</p>

<pre><code>def self.included(base)
  base.extend ClassMethods
  class &lt;&lt; base
    # 用belongs_to_with_deleted重写belongs_to
    alias_method_chain :belongs_to, :deleted
  end
end

module ClassMethods
  def belongs_to_with_deleted(target, options = {})
    # 从options移除with_deleted的值并返回
    with_deleted = options.delete(:with_deleted)
    # 由于返回的是result,假如with_deleted是false,将使用原生的belongs_to方法,即belongs_to_with_deleted,假如是true,也是会返回belongs_to的结果留待下面的操作
    result = belongs_to_without_deleted(target, options)

    # 按照上面的例子,target是:deleted_school
    # 会用到:deleted_school_with_unscoped代替:deleted_school
    # 而原先的用:deleted_school_without_unscoped
    if with_deleted
      # 增加一个option: with_deleted
      result.options[:with_deleted] = with_deleted
      # 在我们上面的例子中,target就是:deleted_school
      unless method_defined? "#{target}_with_unscoped"
        # 实例方法
        class_eval &lt;&lt;-RUBY, __FILE__, __LINE__
          def #{target}_with_unscoped(*args)
            # 取出关联关系,包括school的记录
            association = association(:#{target})
            return nil if association.options[:polymorphic] &amp;&amp; association.klass.nil?
            # 如果school没有用paranoid,就直接用原生的belongs_to
            return #{target}_without_unscoped(*args) unless association.klass.paranoid?
            # 去掉default_scope,scoping跟scoped的作用差不多,不过是接一个block
            association.klass.with_deleted.scoping { #{target}_without_unscoped(*args) }
          end
          alias_method_chain :#{target}, :unscoped
        RUBY
      end
    end

    result
  end
end
</code></pre>

<p>  end
end
```</p>

<p>其实上面的代码就是把belongs_to方法重写了,主要是<code>alias_method_chain :belongs_to, :deleted</code>发挥作用,它的意思是会用belongs_to_with_deleted重写原来的belongs_to方法,原来那个就变成belongs_to_without_deleted方法</p>

<p>相当于这样</p>

<p><code>ruby
alias_method :belongs_to_without_deleted, :belongs_to
alias_method :belongs_to, :belongs_to_with_deleted
</code></p>

<p>在ruby2.0之后会用<a href="http://dev.af83.com/2012/10/19/ruby-2-0-module-prepend.html">module prepend</a>代替它</p>

<p>不明白的可以看<a href="http://dev.iforeach.com/blogs/2011-02-15/alias-alias_method-and-alias_method_chain-compare">alias-alias_method-and-alias_method_chain-compare</a>和<a href="http://apidock.com/rails/Module/alias_method_chain">alias_method_chain</a></p>

<p>上述的代码总结一下,首先重写了belongs_to的代码,让它可以加个with_deleted的参数,但通过squad.deleted_school,就会通过association(:deleted_school)这个方法找所属的school(包含default_scope),然而最后一句<code>association.klass.with_deleted.scoping { #{target}_without_unscoped(*args) }</code>能够去掉default_scope,因为用了with_deleted嘛</p>

<h3>Recovery 还原</h3>

<p>假如把一个邮件放到垃圾箱里,那个垃圾箱应该有个清空(真删除)的操作,也要有个还原的操作,现在我们来介绍这个还原的功能</p>

<p><img src="/images/acts_as_paranoid/recover.png"></p>

<p>源码是这样的</p>

<p>``` ruby
def recover(options={})
  # 这样组织参数很灵活
  options = {</p>

<pre><code>:recursive =&gt; self.class.paranoid_configuration[:recover_dependent_associations],
:recovery_window =&gt; self.class.paranoid_configuration[:dependent_recovery_window]
</code></pre>

<p>  }.merge(options)</p>

<p>  self.class.transaction do</p>

<pre><code>run_callbacks :recover do
  # 通过options[:recursive]的值来判断是否要连带还原
  recover_dependent_associations(options[:recovery_window], options) if options[:recursive]

  self.paranoid_value = nil
  self.save
end
</code></pre>

<p>  end
end
```</p>

<p>它的主要内容是<code>self.paranoid_value = nil</code>,然后再保存(save),这样就可以还原成功</p>

<p>它还带了两个参数,一个叫recursive,它是关于<strong>连带还原</strong>的,也就是说你把school还原了,顺便把属于school的squads(班级)也给还原了</p>

<p>还有另外一个叫recovery_window,它是一个间隔时间,它的作用跟上文说过deleted_inside_time_window差不多,这个recovery_window参数是跟子类的deleted_at时间比较的</p>

<p>而这两个参数都有默认值,而且是从paranoid_configuration这个变量读取的,也就是说在使用acts_as_paranoid就可以给它指定值了,不一定要从recover(options={})中的options传入</p>

<p>看这个就知道了</p>

<p><code>ruby lib/acts_as_paranoid.rb
self.paranoid_configuration = { :column =&gt; "deleted_at", :column_type =&gt; "time", :recover_dependent_associations =&gt; true, :dependent_recovery_window =&gt; 2.minutes }
</code></p>

<p>主要的内容在这一行<code>recover_dependent_associations(options[:recovery_window], options) if options[:recursive]</code></p>

<p>``` ruby
def recover_dependent_associations(window, options)
  self.class.dependent_associations.each do |reflection|</p>

<pre><code># 同样的,没有使用acts_as_paranoid的子类model跳过
next unless reflection.klass.paranoid?

scope = reflection.klass.only_deleted

# Merge in the association's scope
scope = scope.merge(association(reflection.name).association_scope)

# We can only recover by window if both parent and dependant have a
# paranoid column type of :time.
if self.class.paranoid_column_type == :time &amp;&amp; reflection.klass.paranoid_column_type == :time
  scope = scope.merge(reflection.klass.deleted_inside_time_window(paranoid_value, window))
end

scope.each do |object|
  object.recover(options)
end
</code></pre>

<p>  end
end
```</p>

<p>这个方法的内容跟destroy_dependent_associations差不多,也是想通过association找到相关联的记录(squads),有区别是下面这几行</p>

<p>``` ruby</p>

<h1>self是自己,reflection.class是每个关联的子类model</h1>

<p>if self.class.paranoid_column_type == :time &amp;&amp; reflection.klass.paranoid_column_type == :time
  scope = scope.merge(reflection.klass.deleted_inside_time_window(paranoid_value, window))
end</p>

<p>scope.each do |object|
  object.recover(options)
end
```</p>

<p>首先通过判断paranoid_column_type的类型是否是time,因为只有time类型才会用到deleted_inside_time_window,然后遍历scope来执行recover</p>

<h3>Validation 验证</h3>

<p>这里的验证是唯一性验证,它的意思是一个字段不能存同个相同的值,例如身份证号码,是唯一的.但是一条记录被假删除之后,在用户层次,这里数据已经不复存在了(虽然数据库还保留着),所以即使有唯一性的验证,这条记录还是应该被允许重新覆盖那个唯一性的字段。但是仅仅用rails提供的uniqueness验证就不够,因为它是不管你有没有假删除的,就是不能允许有重复的值,所以acts_as_paranoid提供了自己的验证方法。</p>

<p><img src="/images/acts_as_paranoid/validation.png"></p>

<p>自己定义一个validator是这样的</p>

<p>``` ruby
class EmailValidator &lt; ActiveModel::EachValidator
  def validate_each(record, attribute, value)</p>

<pre><code>unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\z/i
  record.errors[attribute] &lt;&lt; (options[:message] || "is not an email")
end
</code></pre>

<p>  end
end</p>

<p>class Person &lt; ActiveRecord::Base
  validates :email, :presence => true, :email => true
end
```</p>

<p>必须定义一个类继承ActiveModel::EachValidator,在这个类下还有定义validate_each方法,具体的可以看<a href="http://guides.rubyonrails.org/active_record_validations.html">rails guides validation</a></p>

<p>而validates_as_paranoid的源码是这样的</p>

<p><code>ruby
def validates_as_paranoid
  include ActsAsParanoid::Validations
end
</code></p>

<p>ActsAsParanoid::Validations它的源码放在lib/acts_as_paranoid/validations.rb文件</p>

<p>``` ruby</p>

<h1><a href="https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/array/wrap.rb">https://github.com/rails/rails/blob/master/activesupport/lib/active_support/core_ext/array/wrap.rb</a> 只是对Array的扩展,把对象包裹成array返回</h1>

<p>require &lsquo;active_support/core_ext/array/wrap&rsquo;</p>

<p>module ActsAsParanoid
  module Validations</p>

<pre><code>def self.included(base)
  base.extend ClassMethods
end

# ActiveRecord::Validations::UniquenessValidator也是继承自ActiveModel::EachValidator
class UniquenessWithoutDeletedValidator &lt; ActiveRecord::Validations::UniquenessValidator
  # 这个validate_each方法是必须定义的
  def validate_each(record, attribute, value)
    # 找到记录的class
    finder_class = find_finder_class_for(record)
    table = finder_class.arel_table

    coder = record.class.serialized_attributes[attribute.to_s]

    if value &amp;&amp; coder
      value = coder.dump value
    end

    relation = build_relation(finder_class, table, attribute, value)
    [Array(finder_class.primary_key), Array(record.send(:id))].transpose.each do |pk_key, pk_value|
      relation = relation.and(table[pk_key.to_sym].not_eq(pk_value))
    end if record.persisted?

    Array.wrap(options[:scope]).each do |scope_item|
      scope_value = record.send(scope_item)
      relation = relation.and(table[scope_item].eq(scope_value))
    end

    # Re-add ActsAsParanoid default scope conditions manually.
    if finder_class.unscoped.where(finder_class.paranoid_default_scope_sql).where(relation).exists?
      record.errors.add(attribute, :taken, options.except(:case_sensitive, :scope).merge(:value =&gt; value))
    end
  end
end
module ClassMethods
  def validates_uniqueness_of_without_deleted(*attr_names)
    validates_with UniquenessWithoutDeletedValidator, _merge_attributes(attr_names)
  end
end
</code></pre>

<p>  end
end
```</p>

<p>上面的validate_each应该跟rails提供的UniquenessValidator中的<a href="http://api.rubyonrails.org/v3.2.13/classes/ActiveRecord/Validations/UniquenessValidator.html">validate_each</a>做比较</p>

<p>最大的不同在于下面两个</p>

<p>``` ruby
&ndash; relation = relation.and(table[finder_class.primary_key.to_sym].not_eq(record.send(:id))) if record.persisted?
+ [Array(finder_class.primary_key), Array(record.send(:id))].transpose.each do |pk_key, pk_value|
+   relation = relation.and(table[pk_key.to_sym].not_eq(pk_value))
+ end if record.persisted?</p>

<h1>这里才是主要的变化</h1>

<ul>
<li>if finder_class.unscoped.where(relation).exists?</li>
<li>if finder_class.unscoped.where(finder_class.paranoid_default_scope_sql).where(relation).exists?
```</li>
</ul>


<p>其实UniquenessWithoutDeletedValidator做的就是重写原生的ActiveRecord::Validations::UniquenessValidator,加上自己的改动,把唯一性验证的范围缩小(finder_class.paranoid_default_scope_sql),最后达到目的</p>

<h3>Callback 回调方法</h3>

<p>acts_as_paranoid提供了一组回调方法, before_recover &amp; after_after</p>

<p>``` ruby
class School &lt; ActiveRecord::Base
  acts_as_paranoid
  before_recover :br
  def br</p>

<pre><code>if deleted?
  puts 'running before recover'
end
</code></pre>

<p>  end
  after_recover :ar
  def ar</p>

<pre><code>unless deleted?
  puts 'running after recover'
end
</code></pre>

<p>  end
end
```</p>

<p><img src="/images/acts_as_paranoid/recover_callback.png"></p>

<p>关于自定义callback可以看<a href="http://api.rubyonrails.org/classes/ActiveSupport/Callbacks.html">activesupport/callbacks</a></p>

<p>现在我们来看下源码</p>

<p>``` ruby lib/acts_as_paranoid.rb</p>

<h1>Push the recover callback onto the activerecord callback list</h1>

<p>ActiveRecord::Callbacks::CALLBACKS.push(:before_recover, :after_recover)
```</p>

<p>``` ruby lib/acts_as_paranoid/core.rb
def self.extended(base)
  # 定义recover回调方法
  base.define_callbacks :recover
end</p>

<h1>设置before_recover这个回调方法所使用的方法</h1>

<p>def before_recover(method)
  set_callback :recover, :before, method
end</p>

<h1>设置after_recover这个回调方法所使用的方法</h1>

<p>def after_recover(method)
  set_callback :recover, :after, method
end</p>

<p>def recover(options={})
  &hellip;
  self.class.transaction do</p>

<pre><code># 这行是执行callback
run_callbacks :recover do
  recover_dependent_associations(options[:recovery_window], options) if options[:recursive]

  self.paranoid_value = nil
  self.save
end
</code></pre>

<p>  end
end
```</p>

<p>总结一下,自定义一个callback,需要三个方法define_callbacks, set_callback, run_callbacks</p>

<p>define_callbacks是定义一个回调方法的名称,例如recover,而set_callback是设置before或after回调方法使用的方法,run_callbacks是运行回调方法,会前后运行before和after回调方法</p>

<h2>总结</h2>

<p>学习一个gem总能获得各种各样的知识,从这个gem我们就学习到了如果自定义一个validator,自定义一个callback,掌握它们方便我们去使用它们.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ancestry源码分析]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/14/ancestryyuan-ma-fen-xi/"/>
    <updated>2013-12-14T21:12:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/14/ancestryyuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<ul>
<li><a href="https://github.com/stefankroes/ancestry">ancestry</a></li>
</ul>


<h3>这个gem是做什么的,原理是什么</h3>

<p>这个gem跟<a href="/blog/2013/12/09/acts-as-treeyuan-ma-fen-xi/">acts_as_tree</a>的作用是一样的,不明白的同学可以看这篇<a href="/blog/2013/12/09/acts-as-treeyuan-ma-fen-xi/">blog</a>.而且在这篇blog我们不直接来分析代码,而是通过使用ancestry的功能来分析代码,并作些比较.由于个人感觉这个gem的代码有点老式,会加上我自己认为可以改进的代码.</p>

<p>这个gem的版本是1.3.0,关于新版的变化可以看文章的最后部分</p>

<h3>架构</h3>

<p><strong>数据库表</strong></p>

<p><img src="/images/ancestry/table.png"></p>

<!-- more -->


<p><img src="/images/ancestry/table_content.png"></p>

<p>在acts_as_tree中只要一个字段来存父与子的关系,然后用<code>has_many :children</code>和<code>belongs_to :parent</code>,而ancestry也是用一个字段(ancestry),不过它的存取方式跟acts_as_tree是不一样的,它不止存着父的id，还存父的父,也就是说存了祖先的id(62/63),而ancestry_depth存的是层次,类似于祖谱中的辈分,祖先是0(第一代),它的儿子是1(第二代)</p>

<p>在上面的图中,id为62的comment就是root(祖先),它的ancestry是<strong>NULL</strong>,它的ancestry_depth是0</p>

<p>id为64的comment的父为63,63的父为62,所以64的ancestry为62/63</p>

<p>假如在id为64的comment下创建一个子,那这个子的ancestry就为62/63/64</p>

<p>要找64的父也很简单,只要查找一下ancestry这个字段的值,最后一个数字就是了
要找64的祖先也很简单,ancestry的第一个数字就是</p>

<p>ancestry这个gem就是以这种方式来找子和父和存储整个关系的</p>

<p>这种存储方式较act_as_tree的parent_id有更好的先进性</p>

<ul>
<li><strong>查询速度快</strong></li>
</ul>


<p>只存父的id(parent_id)要找祖先的话很麻烦的,只能一层一层往上找,很耗时间</p>

<ul>
<li><strong>查询和操作功能多</strong></li>
</ul>


<p>acts_as_tree只支持几个较简单的查询,查父:parent,查子:children,查祖先:ancestors,查根等</p>

<p>而ancestry支持的查询就很多了,除了上面的,还能查path,children_ids之类的</p>

<p>两者的区别的原因在于实现的方式不一样,acts_as_tree就是通过实例方法来实现的,而ancestry是通过scope
来实现(比较灵活),下面会讲到</p>

<p><strong>源码文件</strong></p>

<p><img src="/images/ancestry/source_tree.png"></p>

<p>只有五个文件</p>

<ul>
<li><strong>ancestry.rb</strong>: 主程序文件,一些require语句</li>
<li><strong>class_methods.rb</strong>: 类方法的集全</li>
<li><strong>instance_methods.rb</strong>: 实例方法的集合</li>
<li><strong>exceptions.rb</strong>: 自定义的例外(关于报错的)</li>
<li><strong>has_ancestry.rb</strong>: 关于has_ancestry这个方法的源码</li>
</ul>


<p>PS:我觉得instance_methods.rb和class_methods.rb还有has_ancestry.rb可以合并在一个文件</p>

<p>然后</p>

<p>``` ruby</p>

<p>module Ancestry
  extend ActiveSupport::Concern</p>

<p>  included do
  end</p>

<p>  module ClassMethods
  # class_methods.rb文件的内容可放于此
  end</p>

<p>  module InstanceMethods
  # instance_methods.rb文件的内容可放于此
  end
end</p>

<p>```</p>

<p>或者</p>

<p>``` ruby
module Ancestry
  def self.included(base)</p>

<pre><code>base.extend ClassMethods
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>def has_ancestry
  ...
  include Ancestry::InstanceMethods
end
</code></pre>

<p>  end</p>

<p>  module InstanceMethods
  end
end
```</p>

<p>而has_ancestry的是这样的</p>

<p>``` ruby
  class &lt;&lt; ActiveRecord::Base # 继承到ActiveRecord::Base都有has_ancestry这个方法哦</p>

<pre><code>def has_ancestry options={}
  # Include instance methods
  include Ancestry::InstanceMethods

  # Include dynamic class methods
  extend Ancestry::ClassMethods
  .......
end
</code></pre>

<p>  end
```</p>

<h3>根据功能来解析代码</h3>

<h4>创建根(root)</h4>

<p>你懂的<code>root = Comment.create</code></p>

<p><img src="/images/ancestry/root.png"></p>

<h4>在根(root)下创建个孩子</h4>

<p><code>first_children = root.children.create</code></p>

<p><img src="/images/ancestry/first_children.png"></p>

<p>在acts_as_tree也可以通过这样的方式来创建子
但在ancestry中是没有<code>has_many children</code>的
猜想一下源码肯定会有一个实例方法叫children(<code>root.children</code>)
即使有这个方法也不能create啊
ancestry用了一个方式来实现,正是scope,可以说很多的查询都是基于它</p>

<p>你肯定用过类似<code>Topic.where(:title =&gt; 'xx').order("created_at DESC").limit(4)</code>这样的方法
就是用的scope</p>

<p>先来看看实例方法<strong>children</strong></p>

<p><code>ruby instance_methods.rb
def children
  self.base_class.scoped :conditions =&gt; child_conditions
end
</code></p>

<p>base_class是什么东西呢</p>

<p>``` ruby has_ancestry.rb
class &lt;&lt; ActiveRecord::Base
  &hellip;
  # Save self as base class (for STI)
  def ancestry options={}</p>

<pre><code># :base_class是个类变量(相当于java中的static变量)
cattr_accessor :base_class
# self就是Comment
self.base_class = self
</code></pre>

<p>  end
  &hellip;
end
```</p>

<p>原来就是引用<strong>Comment</strong>自己嘛</p>

<p>scoped是什么呢,看这里<a href="http://apidock.com/rails/ActiveRecord/NamedScope/ClassMethods/scoped">scoped</a></p>

<p>child_conditions呢</p>

<p>``` ruby instance_methods.rb</p>

<h1>Children</h1>

<h1>改了ancestry值了哦,这个时候对象变"脏"了</h1>

<p>def child_conditions
  {self.base_class.ancestry_column => child_ancestry}
end
```</p>

<p>ancestry_column默认是ancestry,就是数据库那个列名</p>

<p>``` ruby has_ancestry.rb</p>

<h1>Create ancestry column accessor and set to option or default</h1>

<p>cattr_accessor :ancestry_column
self.ancestry_column = options[:ancestry_column] || :ancestry
```</p>

<p>重头戏在<strong>child_ancestry</strong></p>

<p>``` ruby instance_methods.rb</p>

<h1>The ancestry value for this record&rsquo;s children</h1>

<p>def child_ancestry
  # New records cannot have children
  raise Ancestry::AncestryException.new(&lsquo;No child ancestry for new record. Save record before performing tree operations.&rsquo;) if new_record?</p>

<p>  # 这段代码比较长,最佳实践不推荐这样写,应该拆成多行
  # 求原始数据,was
  if self.send(&ldquo;#{self.base_class.ancestry_column}<em>was&rdquo;).blank? then id.to_s else &ldquo;#{self.send &rdquo;#{self.base_class.ancestry_column}</em>was"}/#{id}&ldquo; end
end
```</p>

<p><code>"#{self.base_class.ancestry_column}_was"</code>这是什么东西来的,看这里<a href="http://api.rubyonrails.org/classes/ActiveModel/Dirty.html">Active Model Dirty</a></p>

<p><strong>root</strong>的<strong>ancestry</strong>(root.base_class.ancestry_column)就是<strong>nil</strong>,所以<code>self.base_class_column =&gt; child_ancestry</code>就是<strong>root</strong>的<strong>id.to_s(&ldquo;72&rdquo;)</strong></p>

<p>如果不是root呢,那就是<code>"#{self.send "#{self.base_class.ancestry_column}_was"}/#{id}"</code>,例如如果是first_children,那就是"72/73"</p>

<p>经过<strong>child_conditions</strong>,ancestry的值被改变了,我们通过scoped链过来的build方法看它的改变,所以</p>

<p><img src="/images/ancestry/root_ancestry_changes.png">
<img src="/images/ancestry/first_child_ancestry_changes.png"></p>

<p>这个时候save一下就会将数据保存到数据库中了</p>

<p>看一下几个关于children的方法</p>

<p>``` ruby instance_methods.rb</p>

<h1>查找所有孩子的id</h1>

<p>def child_ids
  # 在rails 3或4中可以用children.pluck(:id)
  children.all(:select => self.base_class.primary_key).map(&amp;self.base_class.primary_key.to_sym)
end</p>

<h1>判断是否有孩子</h1>

<p>def has_children?
  self.children.exists?({})
end</p>

<h1>是否叶子节点(没有孩子)</h1>

<p>def is_childless?
  !has_children?
end
```</p>

<h4>在first_children创建一个siblings(兄弟)节点</h4>

<p><img src="/images/ancestry/siblings_changes.png"></p>

<p>``` ruby instance_methods.rb</p>

<h1>Siblings</h1>

<h1>变成跟自己(first_children)一样的ancestry</h1>

<h1>改ancestry值,对象变"脏"(Dirty)</h1>

<p>def sibling_conditions
  {self.base_class.ancestry_column => read_attribute(self.base_class.ancestry_column)}
end</p>

<h1>返回所有的兄弟节点,是包括自己的(first_children),因为是根据ancestry(父)来查的</h1>

<p>def siblings
  self.base_class.scoped :conditions => sibling_conditions
end</p>

<h1>返回所有的兄弟节点的id</h1>

<p>def sibling_ids
   siblings.all(:select => self.base_class.primary_key).collect(&amp;self.base_class.primary_key.to_sym)
end</p>

<p>def has_siblings?
  self.siblings.count > 1
end</p>

<p>def is_only_child?
  !has_siblings?
end
```</p>

<p>如果不让siblings包含自己,只要<code>first_children.siblings - [first_children]</code>就行了</p>

<h4>指定父(parent)节点创建一个Comment</h4>

<p>在comment.rb的白名单上加 <code>attr_accessible :parent</code></p>

<p><img src="/images/ancestry/create_with_parent.png"></p>

<p>既然可以指定<strong>parent</strong>,那一定有<code>parent=()</code>这个方法</p>

<p>``` ruby instance_methods.rb</p>

<h1>Parent</h1>

<h1>找到父那个对象再去找父的child_ancestry,即假如父为根就是它的id&hellip;</h1>

<p>def parent= parent
  write_attribute(self.base_class.ancestry_column, if parent.blank? then nil else parent.child_ancestry end)
end</p>

<h1>还是会执行paren= parent方法</h1>

<p>def parent_id= parent_id
  self.parent = if parent_id.blank? then nil else self.base_class.find(parent_id) end
end</p>

<h1>返回祖先链的最后一个id,即父的id,ancestors下面会讲到</h1>

<p>def parent_id
  if ancestor_ids.empty? then nil else ancestor_ids.last end
end</p>

<h1>用id找到那个parent,找不到就是nil</h1>

<p>def parent
  if parent_id.blank? then nil else self.base_class.find(parent_id) end
end
```</p>

<h4>查找刚创建的第三代的祖先链</h4>

<p><img src="/images/ancestry/ancestor_search.png"></p>

<p>``` ruby instance_methods.rb</p>

<h1>Ancestors</h1>

<h1>读取ancestry的值split后组成数组,取变量的值没有查数据库</h1>

<p>def ancestor_ids
  read_attribute(self.base_class.ancestry_column).to_s.split(&lsquo;/&rsquo;).map { |id| cast_primary_key(id) }
end</p>

<h1>把ancestor_ids数组传给id</h1>

<p>def ancestor_conditions
  {self.base_class.primary_key => ancestor_ids}
end</p>

<p>def ancestors depth_options = {}
  self.base_class.scope_depth(depth_options, depth).ordered_by_ancestry.scoped :conditions => ancestor_conditions
end</p>

<p>def path_ids
  ancestor_ids + [id]
end</p>

<p>def path_conditions
  {self.base_class.primary_key => path_ids}
end</p>

<p>def path depth_options = {}
  self.base_class.scope_depth(depth_options, depth).ordered_by_ancestry.scoped :conditions => path_conditions
end
```</p>

<p><strong>scope_depth</strong>是个类方法,看它之前先来看看架构那部分那里,表据表除了有个<strong>ancestry</strong>字段,还有<strong>ancestry_depth</strong>这个字段</p>

<p>这个<strong>ancestry_depth</strong>就是类变量<strong>depth_cache_column</strong>定义的</p>

<p>``` ruby has_ancestry.rb</p>

<h1>Create ancestry column accessor and set to option or default</h1>

<p>if options[:cache_depth]
  # Create accessor for column name and set to option or default
  self.cattr_accessor :depth_cache_column
  self.depth_cache_column = options[:depth_cache_column] || :ancestry_depth</p>

<p>  # Cache depth in depth cache column before save
  # 验证depth_cache_column必须是整数且大于或等于0
  before_validation :cache_depth</p>

<p>  # Validate depth column
  validates_numericality_of depth_cache_column, :greater_than_or_equal_to => 0, :only_integer => true, :allow_nil => false
end</p>

<h1>Create named scopes for depth</h1>

<h1>下面就是一个条件,跟ancestry_depth比,例如before_depth就是'&ldquo;ancestry_depth &lt; ?&rdquo;, 3'之类的</h1>

<p>{:before_depth => &lsquo;&lt;&rsquo;, :to_depth => &lsquo;&lt;=&rsquo;, :at_depth => &lsquo;=&rsquo;, :from_depth => &lsquo;>=&rsquo;, :after_depth => &lsquo;>&rsquo;}.each do |scope_name, operator|
  # send scope_method就是定义一个scope
  send scope_method, scope_name, lambda { |depth|</p>

<pre><code>raise Ancestry::AncestryException.new("Named scope '#{scope_name}' is only available when depth caching is enabled.") unless options[:cache_depth]
{:conditions =&gt; ["#{depth_cache_column} #{operator} ?", depth]}
</code></pre>

<p>  }
end
```
<img src="/images/ancestry/scope_depth.png"></p>

<p>为什么数字会改变呢,原来那个<strong>before_depth</strong>不是基于<strong>root</strong>(根),而是基于<strong>c</strong>(孙),<strong>c</strong>有两个前辈1+1=2,所以数据库查的是2+2=4</p>

<p>``` ruby class_methods.rb解读scope_depth
def ancestors depth_options = {}
  self.base_class.scope_depth(depth_options, depth).ordered_by_ancestry.scoped :conditions => ancestor_conditions
end</p>

<h1>也就是自己ancestry_depth的值</h1>

<p>def depth
  ancestor_ids.size
end</p>

<p>def scope_depth depth_options, depth
  # inject方法很灵活
  depth_options.inject(self.base_class) do |scope, option|</p>

<pre><code># relative_depth是传进来的值
scope_name, relative_depth = option
if [:before_depth, :to_depth, :at_depth, :from_depth, :after_depth].include? scope_name
  # ancestry_depth的值加上传进来的值
  scope.send scope_name, depth + relative_depth
else
  raise Ancestry::AncestryException.new("Unknown depth option: #{scope_name}.")
end
</code></pre>

<p>  end
end</p>

<p>scope_method = if rails_3 then :scope else :named_scope end</p>

<h1>很多方法用到这个,在rails 3中会变成send :scope, :ordered_by_ancestry&hellip;</h1>

<h1>如果是根会排在前面</h1>

<p>send scope_method, :ordered_by_ancestry, :order => &ldquo;(case when #{table_name}.#{ancestry_column} is null then 0 else 1 end), #{table_name}.#{ancestry_column}&rdquo;
```</p>

<h4>其他几个查询方法</h4>

<p>主要是<strong>subtree</strong>和<strong>root</strong></p>

<p>``` ruby</p>

<h1>Subtree</h1>

<h1>包括自己查后代,使用self.id, child_ancestry是查自己的子,&ldquo;#{child_ancestry}/"查孙一代起</h1>

<p>def subtree_conditions
  [&ldquo;#{self.base_class.table_name}.#{self.base_class.primary_key} = ? or #{self.base_class.table_name}.#{self.base_class.ancestry_column} like ? or #{self.base_class.table_name}.#{self.base_class.ancestry_column} = ?&rdquo;, self.id, &ldquo;#{child_ancestry}/%&rdquo;, child_ancestry]
end</p>

<p>def subtree depth_options = {}
  self.base_class.ordered_by_ancestry.scope_depth(depth_options, depth).scoped :conditions => subtree_conditions
end</p>

<p>def subtree_ids depth_options = {}
  subtree(depth_options).all(:select => self.base_class.primary_key).collect(&amp;self.base_class.primary_key.to_sym)
end</p>

<h1>Root</h1>

<h1>返回根的id,在acts_as_tree可是要遍历的,这个就简单多了</h1>

<h1>ancestor_ids是空的,那就返回自己的id</h1>

<p>def root_id
  if ancestor_ids.empty? then id else ancestor_ids.first end
end</p>

<h1>如果根就是自己,那就不用查了</h1>

<p>def root
  if root_id == id then self else self.base_class.find(root_id) end
end</p>

<h1>判断是不是nil而已</h1>

<p>def is_root?
  read_attribute(self.base_class.ancestry_column).blank?
end
```</p>

<h4>将第三代c的父改为根(root),变成了第二代</h4>

<p>第三代要变成第二代,把ancestry改为第一代的id,ancestry_depth从2变成1即可</p>

<p><strong>但是</strong>第三代也有后代,而且可能有很多(第四代,第五代&hellip;),他们怎么办</p>

<p>改变前:</p>

<p><img src="/images/ancestry/before_change_parent.png"></p>

<p><img src="/images/ancestry/change_parent.png"></p>

<p>改变后:</p>

<p><img src="/images/ancestry/after_change_parent.png"></p>

<p>先来看看ancestry的变化</p>

<p>他的后代的ancestry的变化是通过<strong>before_save</strong>来实现的</p>

<p>在<strong>before_save</strong>之前c(77)的ancestry最先变化,它由"72/73"变成了"72"</p>

<p>看上面那个命令图,第一个改的后代是id为78(c的子)那个
它由"72/73/77"变成"72/77"</p>

<p>id为79(c的孙)那个Comment的ancestry由"72/73/77/78"变成"72/77/78"</p>

<p>看出一个规律就是把"72/73"变成"72"罢了,其他的不变,因为c的ancestry由"72/73"变成了"72",所以它的后代跟着变</p>

<p>如果上面推测正确,那么&hellip;</p>

<p>``` ruby has_ancestry.rb</p>

<h1>Update descendants with new ancestry before save</h1>

<p>before_save :update_descendants_with_new_ancestry
```</p>

<p>``` ruby instance_methods.rb</p>

<h1>Descendants</h1>

<h1>查的是所有后代,下面的update_descendants_with_new_ancestry会用到</h1>

<p>def descendant_conditions
  [&ldquo;#{self.base_class.table_name}.#{self.base_class.ancestry_column} like ? or #{self.base_class.table_name}.#{self.base_class.ancestry_column} = ?&rdquo;, &ldquo;#{child_ancestry}/%&rdquo;, child_ancestry]
end</p>

<p>def descendants depth_options = {}
  self.base_class.ordered_by_ancestry.scope_depth(depth_options, depth).scoped :conditions => descendant_conditions
end</p>

<h1>在外面包装一个scope</h1>

<p>def unscoped_descendants
  # with_exclusive_scope就是with_scope,不明白的可以看<a href="http://apidock.com/rails/ActiveRecord/Base/with_scope/class">http://apidock.com/rails/ActiveRecord/Base/with_scope/class</a>
  self.base_class.send(:with_exclusive_scope) do</p>

<pre><code>self.base_class.all(:conditions =&gt; descendant_conditions)
</code></pre>

<p>  end
end</p>

<h1>Update descendants with new ancestry</h1>

<p>def update_descendants_with_new_ancestry
  # Skip this if callbacks are disabled
  # ancestry_callbacks_disabled?是一个开关,为了让下面的更改有序的进行而不发生数据更改的碰撞,可以看下面相关的代码
  unless ancestry_callbacks_disabled?</p>

<pre><code># If node is valid, not a new record and ancestry was updated ...
# ancestry_column肯定先改变啦,那就那个c的值啦,!new_reocrd?也肯定不是新数据啦,必须要是有效的valid?(验证通过)
if changed.include?(self.base_class.ancestry_column.to_s) &amp;&amp; !new_record? &amp;&amp; valid?
  # ... for each descendant ...
  # 会去循环每个后代哦
  unscoped_descendants.each do |descendant|
    # ... replace old ancestry with new ancestry
    # 进行有without_ancestry_callbacks的代码,里面包装的是一个原子操作,防止数据被错误修改
    descendant.without_ancestry_callbacks do
      # 更改ancestry的值哦
      descendant.update_attribute(
        # 就是ancestry那个列嘛
        self.base_class.ancestry_column,
        # 读取每个后代ancestry的值,gsub进行全局替换
        descendant.read_attribute(descendant.class.ancestry_column).gsub(
          # child_ancestry是没变之前的ancestry的值,例如上例中的c的ancestry值"72/73"
          /^#{self.child_ancestry}/,
          # self就是c,替换成c现有的值,也就是"72"
          if read_attribute(self.class.ancestry_column).blank? then id.to_s else "#{read_attribute self.class.ancestry_column }/#{id}" end
        )
      )
    end
  end
end
</code></pre>

<p>  end
end</p>

<h1>开关控制</h1>

<h1>Callback disabling</h1>

<p>def without_ancestry_callbacks
  @disable_ancestry_callbacks = true
  yield
  @disable_ancestry_callbacks = false
end</p>

<p>def ancestry_callbacks_disabled?
  !!@disable_ancestry_callbacks
end
```</p>

<p>代码果然如我们预期的效果一样</p>

<p>接下来我们来看看ancestry_depth的变化</p>

<p>说到这个必须谈下<code>has_ancestry :cache_depth =&gt; true</code></p>

<p><code>:cache_depth =&gt; true</code>开启了之后就可以在<strong>ancestry_depth</strong>(默认)存树的深度,root为0,第一代为1</p>

<p>``` ruby has_ancestry.rb</p>

<h1>Create ancestry column accessor and set to option or default</h1>

<p>if options[:cache_depth]
  &hellip;
  # Cache depth in depth cache column before save
  # 在验证之前会执行这个的
  before_validation :cache_depth
  &hellip;
end
```</p>

<p>:cache_depth到底做了什么事儿</p>

<p>``` ruby</p>

<h1>求深度,例如,ancestry为'72/73'的深度就是'2'(第三代)</h1>

<p>def depth
  ancestor_ids.size
end</p>

<h1>write_attribute是save(false)的,更改ancestry_depth的值</h1>

<p>def cache_depth
  write_attribute self.base_class.depth_cache_column, depth
end
```</p>

<p>在改descendant时根本没有改它的<strong>ancestry_depth</strong>,所以descendant的ancestry_depth没有即时更新,跟我们预期的结果不一样</p>

<p>只要重载<strong>update_descendants_with_new_ancestry</strong>方法</p>

<p>加上下面的代码就可以解决那个问题了</p>

<p>``` ruby
def update_descendants_with_new_ancestry
  &hellip;
  descendant.update_attribute(</p>

<pre><code>self.base_class.ancestry_column,
descendant.read_attribute(descendant.class.ancestry_column).gsub(
  /^#{self.child_ancestry}/,
  if read_attribute(self.class.ancestry_column).blank? then id.to_s else "#{read_attribute self.class.ancestry_column }/#{id}" end
)
</code></pre>

<p>  )
  # 加入下面的代码哦
  descendant.reload
  descendant.update_attribute(</p>

<pre><code>self.base_class.depth_cache_column,
descendant.depth
</code></pre>

<p>  )
  &hellip;
end
```</p>

<h4>删除c(有后代)</h4>

<p>删除一个Comment很简单,只要把那条记录删除就行了,但是删除后它的后代怎么办</p>

<p>ancestry是通过:orphan_strategy这个参数来控制,而has_ancestry.rb有这句<code>before_destroy :apply_orphan_strategy</code></p>

<p>:orphan_strategy只有三个值: :rootify, :destroy, :restrict</p>

<p>先看下:rootify</p>

<p>改变前:</p>

<p><img src="/images/ancestry/destroy_rootify.png"></p>

<p>改变后:</p>

<p><img src="/images/ancestry/after_destroy_rootify.png"></p>

<p>c被删除后,它的子(81)没有了父,就把ancestry设为NULL,它自己的子(82)的ancestry还是指向自己(81),依此类推&hellip;</p>

<p>其实做的就是把id为82的comment的ancestry:&ldquo;72/73/80/81"的"72/73/80&rdquo;(81的ancestry,也就是c.child_ancestry)删除掉</p>

<p>:destroy就不做这些改变了,直接删除数据</p>

<p>:restrict,只要有后代就抛出异常</p>

<p>来看下代码</p>

<p>``` ruby</p>

<h1>Apply orphan strategy</h1>

<p>def apply_orphan_strategy
  # Skip this if callbacks are disabled
  unless ancestry_callbacks_disabled?</p>

<pre><code># If this isn't a new record ...
unless new_record?
  # ... make all children root if orphan strategy is rootify
  if self.base_class.orphan_strategy == :rootify
    unscoped_descendants.each do |descendant|
      descendant.without_ancestry_callbacks do
        # descendant.ancestry == child_ancestry就是c的子,直接设为NULL
        # 从c的"孙"开始,把ancestry的值前面一部分替换掉,也就是子的ancestry,所有孙之后的后代的这部分都替换成空
        descendant.update_attribute descendant.class.ancestry_column, (if descendant.ancestry == child_ancestry then nil else descendant.ancestry.gsub(/^#{child_ancestry}\//, '') end)
      end
    end
  # ... destroy all descendants if orphan strategy is destroy
  elsif self.base_class.orphan_strategy == :destroy
    unscoped_descendants.each do |descendant|
      descendant.without_ancestry_callbacks do
        # 直接删除后代
        descendant.destroy
      end
    end
  # ... throw an exception if it has children and orphan strategy is restrict
  elsif self.base_class.orphan_strategy == :restrict
    # 抛出异常
    raise Ancestry::AncestryException.new('Cannot delete record because it has descendants.') unless is_childless?
  end
end
</code></pre>

<p>  end
end
```</p>

<h3>总结</h3>

<ol>
<li>通过这个gem我们可以学习比较先进的数据库设计的理念,就是减少数据库的查询次数</li>
<li>学习scope的灵活用法</li>
<li>高效查询算法的设计</li>
</ol>


<hr />

<h3>关于新版本的改变</h3>

<ul>
<li><p>去掉了primary_key_format这个参数(没什么用处)</p></li>
<li><p>用上了reorder这个scope</p></li>
</ul>


<p><code>ruby
-  send scope_method, :ordered_by_ancestry, :order =&gt; "(case when #{table_name}.#{ancestry_column} is null then 0 else 1 end), #{table_name}.#{ancestry_column}"
-  send scope_method, :ordered_by_ancestry_and, lambda { |order| {:order =&gt; "(case when #{table_name}.#{ancestry_column} is null then 0 else 1 end), #{table_name}.#{ancestry_column}, #{order}"} }
+  send scope_method, :ordered_by_ancestry, reorder("(case when #{table_name}.#{ancestry_column} is null then 0 else 1 end), #{table_name}.#{ancestry_column}")
+  send scope_method, :ordered_by_ancestry_and, lambda { |order| reorder("(case when #{table_name}.#{ancestry_column} is null then 0 else 1 end), #{table_name}.#{ancestry_column}, #{order}") }
</code></p>

<ul>
<li><p>不用with_exclusive_scope,用unscoped代替</p></li>
<li><p><code>send scope</code>用<code>scope</code>代替</p></li>
<li><p>/\A[0-9]+(\/[0-9]+)*\Z/这个用常量替换</p></li>
</ul>


<p><code>ruby
-  validates_format_of ancestry_column, :with =&gt; /\A[0-9]+(\/[0-9]+)*\Z/, :allow_nil =&gt; true
+  validates_format_of ancestry_column, :with =&gt; Ancestry::ANCESTRY_PATTERN, :allow_nil =&gt; true
</code></p>

<ul>
<li>更改before_save那个方法</li>
</ul>


<p><code>ruby
-  if changed.include?(self.base_class.ancestry_column.to_s) &amp;&amp; !new_record? &amp;&amp; valid?
+  if changed.include?(self.base_class.ancestry_column.to_s) &amp;&amp; !new_record? &amp;&amp; sane_ancestry?
def sane_ancestry?
  ancestry.nil? || (ancestry.to_s =~ Ancestry::ANCESTRY_PATTERN &amp;&amp; !ancestor_ids.include?(self.id))
end
</code></p>

<ul>
<li>find用unscoped包住</li>
</ul>


<p><code>ruby
-  self.parent = if parent_id.blank? then nil else self.base_class.find(parent_id) end
+  self.parent = if parent_id.blank? then nil else unscoped_find(parent_id) end
def unscoped_find id
  self.base_class.unscoped { self.base_class.find(id) }
end
</code></p>

<ul>
<li>conditions用where代替</li>
</ul>


<p><code>ruby
-  self.base_class.scoped :conditions =&gt; child_conditions
+  self.base_class.where child_conditions
</code></p>

<ul>
<li>用上了select方法</li>
</ul>


<p><code>ruby
-  children.all(:select =&gt; self.base_class.primary_key).map(&amp;self.base_class.primary_key.to_sym)
+  children.select(self.base_class.primary_key).map(&amp;self.base_class.primary_key.to_sym)
</code></p>

<ul>
<li>nil?代替blank?</li>
</ul>


<p><code>ruby
-  write_attribute(self.base_class.ancestry_column, if parent.blank? then nil else parent.child_ancestry end)
+  write_attribute(self.base_class.ancestry_column, if parent.nil? then nil else parent.child_ancestry end)
</code></p>

<ul>
<li>用in查询</li>
</ul>


<p>``` ruby
def ancestor_conditions
  t = get_arel_table
  t[get_primary_key_column].in(ancestor_ids)
end</p>

<p>def get_arel_table
  self.ancestry_base_class.arel_table
end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Association Reference]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/11/rails-association-reference/"/>
    <updated>2013-12-11T10:09:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/11/rails-association-reference</id>
    <content type="html"><![CDATA[<h2>rails关联模型参数的使用</h2>

<p>上一篇<a href="http://yinsigan.github.io/blog/2013/12/10/rails-association/">rails association</a>说明了rails的各种模型的原理和设计,这篇我们来说说rails association具体参数的使用,通过一些案例或代码来分析它们的使用场景</p>

<p><img src="/images/rails_association_reference/has_many_through.png"></p>

<p>``` ruby
class School &lt; ActiveRecord::Base
  has_many :squads
  has_many :students, :through => :squads
end</p>

<p>class Squad &lt; ActiveRecord::Base
  belongs_to :school
  has_many :students
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad
end
```</p>

<h3>Association(关联关系的使用)</h3>

<ul>
<li>association(force_reload = false)强制reload查数据库</li>
</ul>


<!-- more -->


<p>``` ruby
s = Squad.first
s.students
=> [#<Student id: 40, name: "学员1", squad_id: 1, created_at: "2013-12-11 02:43:53", updated_at: "2013-12-11 02:43:53", active: true>,
 #<Student id: 41, name: "学员2", squad_id: 1, created_at: "2013-12-11 02:43:56", updated_at: "2013-12-11 02:43:56", active: true>]</p>

<p>s.students.last.delete #把最后一个学员删除,那班级s只剩下一个学员</p>

<h1>可是还是两个学员</h1>

<p>s.students
=> [#<Student id: 40, name: "学员1", squad_id: 1, created_at: "2013-12-11 02:43:53", updated_at: "2013-12-11 02:43:53", active: true>,
 #<Student id: 41, name: "学员2", squad_id: 1, created_at: "2013-12-11 02:43:56", updated_at: "2013-12-11 02:43:56", active: true>]</p>

<h1>如果传入一个参数true</h1>

<p>s.students(true)
=> [#<Student id: 40, name: "学员1", squad_id: 1, created_at: "2013-12-11 02:43:53", updated_at: "2013-12-11 02:43:53", active: true>]
```</p>

<p>其实传入true就是去数据库查询,不直接从变量(<strong>s.students</strong>)取值
<code>
Student Load (0.8ms)  SELECT `students`.* FROM `students` WHERE `students`.`squad_id` = 1 AND `students`.`active` = 1
</code></p>

<ul>
<li>association=(associate)</li>
</ul>


<p>``` ruby</p>

<h1>good</h1>

<p>s = Student.first
s.squad = Squad.last
s.save</p>

<h1>bad</h1>

<p>s.squad_id = &lsquo;9&rsquo;.to_i
s.save
```</p>

<p>这种方式有两个好处,第一个,你不在白名单(attr_accessible)写上:squad_id,第二个你能保证squad_id就是正确存在的吗</p>

<p>最佳实践也是推鉴这种方式的</p>

<p><code>ruby
current_user.posts.build(params[:post])
</code></p>

<ul>
<li>collection&lt;&lt;(object, …)创建记录</li>
</ul>


<p>这是我们创建记录的主要手段之一</p>

<p><code>ruby
s = Squad.first
s.students &lt;&lt; Student.create(:name =&gt; "学员")
</code></p>

<ul>
<li>collection.delete(object, …)删除关联关系(不删除记录)</li>
</ul>


<p><code>`` ruby
s = Squad.first
s.students.delete(s.students.last) #删除最后一条,只是把值设为NULL
=&gt; SQL (0.6ms)  UPDATE</code>students<code>SET</code>squad_id<code>= NULL WHERE</code>students<code>.</code>squad_id<code>= 1 AND</code>students<code>.</code>active<code>= 1 AND</code>students<code>.</code>id` IN (43)</p>

<p>```</p>

<p>delete_all不用传参数就可以删除所有关联关系了</p>

<p>要保留数据的时候又要去掉关联关系用这种方式最好了</p>

<ul>
<li>collection.delete(object, …)删除记录</li>
</ul>


<p>``` ruby
s = Squad.first
st = s.first
s.students.destroy(st)</p>

<h1>是真正的删除记录</h1>

<p>DELETE FROM <code>students</code> WHERE <code>students</code>.<code>id</code> = 46</p>

<p>```</p>

<p>destroy_all不用传参数就可以删除所有关联的记录了</p>

<ul>
<li>collection_singular_ids=ids(更改关联关系)</li>
</ul>


<p>``` ruby
s = Squad.first</p>

<p>s.student_ids
=> [42, 43]</p>

<p>s.students_ids = [40, 43]</p>

<h1>会查一遍数据表students,没有的id你可别乱来哦</h1>

<p>Student Load (0.8ms)  SELECT <code>students</code>.* FROM <code>students</code> WHERE <code>students</code>.<code>id</code> IN (40, 43)</p>

<h1>不要42了就把关联关系去掉(设为NULL)</h1>

<p>SQL (0.6ms)  UPDATE <code>students</code> SET <code>squad_id</code> = NULL WHERE <code>students</code>.<code>squad_id</code> = 1 AND <code>students</code>.<code>active</code> = 1 AND <code>students</code>.<code>id</code> IN (42)</p>

<h1>把40加进去</h1>

<p>UPDATE <code>students</code> SET <code>squad_id</code> = 1, <code>updated_at</code> = &lsquo;2013-12-11 03:19:40&rsquo; WHERE <code>students</code>.<code>id</code> = 40</p>

<p>```</p>

<p>从表单的复选框传来的数据用这种方式解决最好了</p>

<p>最佳实践就是这么做滴</p>

<p>``` ruby 多角色管理
&lt;% for role in Role.all %></p>

<div>
  <%= check_box_tag "user[role_ids][]", role.id, @user.roles.include?(role) %>
  <%=h role.name %>
</div>


<p>&lt;% end %>
&lt;%= hidden_field_tag &ldquo;user[role_ids][]&rdquo;, &ldquo;&rdquo; %>
```</p>

<ul>
<li>collection.clear会把所有关联关系清除或者删掉</li>
</ul>


<p>``` ruby
s = Squad.first
s.students.clear</p>

<h1>只是把关联关系清除而已</h1>

<p>UPDATE <code>students</code> SET <code>squad_id</code> = NULL WHERE <code>students</code>.<code>squad_id</code> = 1 AND <code>students</code>.<code>active</code> = 1 AND <code>students</code>.<code>id</code> IN (42, 42)</p>

<p>```</p>

<p>如果不止想关联关系清除呢,那个就是要在has_many时加入:dependent => :destroy就可以了</p>

<p>其实看下clear的源码就知道原理</p>

<p>``` ruby</p>

<h1>File activerecord/lib/active_record/associations/association_collection.rb, line 244</h1>

<p>def clear
  return self if length.zero? # forces load_target if it hasn&rsquo;t happened already</p>

<p>  if @reflection.options[:dependent] &amp;&amp; @reflection.options[:dependent] == :destroy</p>

<pre><code>destroy_all
</code></pre>

<p>  else</p>

<pre><code>delete_all
</code></pre>

<p>  end</p>

<p>  self
end
```</p>

<ul>
<li>collection.exists?判断记录是否存在</li>
</ul>


<p>``` ruby
s = Squad.first</p>

<p>s.students.exists?(42)
=> true</p>

<p>s.students.exists?(Student.first)
=> true</p>

<p>s.students.exists?(:id => 42)
=> true
```</p>

<p>用<strong>exists?</strong>来判断比<strong>include?</strong>更灵活,<strong>include?</strong>只支持类似这样<code>inlcude?(Student.first)</code>的判断</p>

<h3>Association Parameter Reference(参数的使用)</h3>

<p>有些参数在上一篇<a href="http://yinsigan.github.io/blog/2013/12/10/rails-association/">rails association</a>已经提及过，例如polymorphic, :through等,这里再阐述几个比较常用或用处比较大的</p>

<ul>
<li>class_name</li>
</ul>


<p>查找实际的类名(model)</p>

<p>``` ruby</p>

<h1>默认情况下是:students的,如果要换个名字,就要指定实际的class_name</h1>

<p>has_many :newest_students, :class_name => &lsquo;Student&rsquo;, :order => &lsquo;created_at DESC&rsquo;</p>

<p>SELECT <code>students</code>.* FROM <code>students</code> WHERE <code>students</code>.<code>squad_id</code> = 1 ORDER BY created_at DESC
```</p>

<ul>
<li>conditions</li>
</ul>


<p>指定查询条件</p>

<p><code>ruby
has_many :students, :conditions =&gt; "active = 1"
</code></p>

<p>在rails 4已经用where代替conditions了</p>

<p>conditions有个要注意的地方</p>

<p><code>:conditions =&gt; "active = 1"</code>和<code>{active: true}</code>(Hash)是不一样的
当你用s.students.create或s.students.build创建student的时候,active的值会不一样
用<code>{active: true}</code>形式创建时不管你的active的默认值是否是true，创建的student的active都是true
而<code>:conditions =&gt; "active = 1"</code>就是看active的默认值</p>

<p>:conditions也可以接proc:<code>:conditions =&gt; proc { ["orders.created_at &gt; ?", 10.hours.ago] }</code></p>

<p>实际项目的代码如下:</p>

<p><code>ruby
class School &lt; ActiveRecord::Base
  has_many :students, :include =&gt; :user, :order =&gt; "users.name DESC", :conditions =&gt; "users.tp = 0"
  has_many :staff_users, :class_name =&gt; "User", :order =&gt; :name, :conditions =&gt; "tp = 1"
  has_many :staffs, :through =&gt; :users, :order =&gt; "users.name DESC", :conditions =&gt; "users.tp = 1"
end
</code></p>

<ul>
<li>counter_cache</li>
</ul>


<p>在数据库中记录孩子的数量</p>

<p><code>bash
rails g migration add_students_count_to_squads students_count:integer
</code></p>

<p>``` ruby
class AddStudentsCountToSquads &lt; ActiveRecord::Migration
  def change</p>

<pre><code>add_column :squads, :students_count, :string
Squad.reset_column_information
Squad.find_each do |p|
  Squad.update_counters p.id, :students_count =&gt; p.students.length
end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad, :counter_cache => true
end
```</p>

<p>默认的字段名是跟关联(has_many)的model是一致的,在上述的例子中就是<strong>students_count</strong>,如果想改变这个name也可以,给:counter_cache指定值就可以了,例如<code>:counter_cache =&gt; :children_count</code></p>

<p>当删除关联关系时(squad_id设为NULL)时,students_count不会更新</p>

<ul>
<li>dependent</li>
</ul>


<p>依赖性</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students, :dependent => :destroy
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad
end
```</p>

<p>如果传入<code>:dependent =&gt; :nullify</code>不删除数据,只删除关联数据</p>

<p>:delete_all和:destroy的区别就是调不调用before_save的问题</p>

<ul>
<li>foreign_key</li>
</ul>


<p>外键</p>

<p><code>ruby
class Topic &lt; ActiveRecord::Base
  belongs_to :creater, :class_name =&gt; 'User', :foreign_key =&gt; "creater_id"
end
</code></p>

<p>当你的model name跟foreign_key不一致时就可以手动指定关联的foreign_key
这样写当<code>topic.creater.try(:name)</code>就可以简单取得创建者的name了</p>

<ul>
<li>include</li>
</ul>


<p>包含查询</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad, :include => :school
end</p>

<p>class School &lt; ActiveRecord::Base
  has_many :squads
end</p>

<p>s = Student.first
s.squad</p>

<h1>查了schools这个表,把数据一并取了出来</h1>

<p>Squad Load (0.3ms)  SELECT <code>squads</code>.<em> FROM <code>squads</code> WHERE <code>squads</code>.<code>id</code> = 14 LIMIT 1
School Load (0.3ms)  SELECT <code>schools</code>.</em> FROM <code>schools</code> WHERE <code>schools</code>.<code>id</code> IN (1)</p>

<h1>前面已经查了schools的数据了,现在不会查sql的</h1>

<p>s.squad.school
```</p>

<p>当你要查<code>Student.first.squad.school</code>就方便多了</p>

<ul>
<li>touch</li>
</ul>


<p>当子类被创建或更改时,更新父类的updated_at</p>

<p>``` ruby
class Student &lt; ActiveRecord::Base
  belongs_to :squad, :touch => true
end</p>

<p>class Squad &lt; ActiveRecord::Base
  has_many :students
end</p>

<p>s = Student.first
s.name = &lsquo;学员&rsquo;
s.save</p>

<h1>其实就是把父的updated_at更新了一下</h1>

<p>UPDATE <code>students</code> SET <code>name</code> = &lsquo;3333333333333&rsquo;, <code>updated_at</code> = &lsquo;2013-12-11 14:59:47&rsquo; WHERE <code>students</code>.<code>id</code> = 86
Squad Load (0.6ms)  SELECT <code>squads</code>.* FROM <code>squads</code> WHERE <code>squads</code>.<code>id</code> = 14 LIMIT 1
SQL (0.7ms)  UPDATE <code>squads</code> SET <code>updated_at</code> = &lsquo;2013-12-11 14:59:47&rsquo; WHERE <code>squads</code>.<code>id</code> = 14
```</p>

<p>如果不想更新updated_at, 还可以指定更新具体的column,例如<code>:touch =&gt; :accessed_at</code></p>

<ul>
<li>validate</li>
</ul>


<p>跳过验证</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students, :validate => true
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad
  validates :name, :presence => true
end</p>

<h1>failure</h1>

<p>Student.create</p>

<h1>success</h1>

<p>s = Squad.first
s.students.create
```</p>

<p>在创建子对象时,可以跳过验证</p>

<ul>
<li>source</li>
</ul>


<p>指定查找源, 和has_one :through或has_many :through一起使用</p>

<p>``` ruby
class School &lt; ActiveRecord::Base
  has_many :squads
  has_many :squads_teachers, :through => :squads, :source => :teachers
end</p>

<p>class Squad &lt; ActiveRecord::Base
  has_many :teachers
  belongs_to :school
end</p>

<p>class Teacher &lt; ActiveRecord::Base
  belongs_to :squad
  belongs_to :staff
end</p>

<p>s = School.first
s.squads_teachers</p>

<h1>查找的是teachers表,不过teachers去joins squads表</h1>

<p>School Load (1.5ms)  SELECT <code>schools</code>.<em> FROM <code>schools</code> LIMIT 1
Teacher Load (90.0ms)  SELECT <code>teachers</code>.</em> FROM <code>teachers</code> INNER JOIN <code>squads</code> ON <code>teachers</code>.<code>squad_id</code> = <code>squads</code>.<code>id</code> WHERE <code>squads</code>.<code>school_id</code> = 1</p>

<h1>grades belongs_to staff</h1>

<p>has_many :grade_teachers, :through => :grades, :source => :staff  #年级组长
```</p>

<p>这种方式用得好真的好灵活</p>

<ul>
<li>group</li>
</ul>


<p>分组</p>

<p>``` ruby
class School &lt; ActiveRecord::Base
  has_many :students, :through => :squads, :group => &lsquo;squads.id&rsquo;
end</p>

<p>s = School.first
s.students</p>

<h1>原理就是在数据库查询的时候加个分组group</h1>

<p>Student Load (81.7ms)  SELECT <code>students</code>.* FROM <code>students</code> INNER JOIN <code>squads</code> ON <code>students</code>.<code>squad_id</code> = <code>squads</code>.<code>id</code> WHERE <code>squads</code>.<code>school_id</code> = 1 GROUP BY squads.id
```</p>

<ul>
<li>:uniq</li>
</ul>


<p>确保查到的数据是唯一的</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :staffs, :through => :teachers, :uniq => true
  has_many :teachers
end</p>

<p>class Staff &lt; ActiveRecord::Base
  has_many :squad, :through => :teachers
  has_many :teachers
end</p>

<p>class Teacher &lt; ActiveRecord::Base
  belongs_to :squad
  belongs_to :staff
end</p>

<p>s = Squad.first
staff = Staff.create
s.staff &lt; staff
s.staff &lt; staff</p>

<h1>如果没有:unqi => true,将会输出多个staffs,数据库也是存在的(相同的数据),加上:unqi => true将只会输出一条数据,这样才符合逻辑</h1>

<p>s.staff</p>

<h1>如果不加这个:uniq => true,这样也可以实现同样的目的</h1>

<p>s.staff.uniq</p>

<p>```</p>

<p>在rails 4用-> { distinct }</p>

<ul>
<li><p>除了这些参数还有<strong>:readonly</strong>, <strong>:order</strong>, <strong>:select</strong>, <strong>:limit</strong>, <strong>:offset</strong>等</p></li>
<li><p>最后来个复杂的项目实例</p></li>
</ul>


<p>``` ruby
class Relationship &lt; ActiveRecord::Base
  belongs_to :follower, class_name: &ldquo;User&rdquo;
  belongs_to :followed, class_name: &ldquo;User&rdquo;
end</p>

<p>class User &lt; ActiveRecord::Base
  has_many :relationships, foreign_key: &ldquo;follower_id&rdquo;, dependent: :destroy
  has_many :followed_users, through: :relationships, source: :followed
  has_many :reverse_relationships, foreign_key: &ldquo;followed_id&rdquo;,</p>

<pre><code>                               class_name:  "Relationship",
                               dependent:   :destroy
</code></pre>

<p>  has_many :followers, through: :reverse_relationships, source: :follower
end
```</p>

<h3>Association Callbacks</h3>

<ul>
<li>before_add 添加前</li>
<li>after_add 添加后</li>
<li>before_remove 删除前</li>
<li>after_remove  删除后</li>
</ul>


<p>这是关联关系的Callbacks</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students, :after_add => :update_accessed_at</p>

<p>  private</p>

<pre><code>def update_accessed_at(student)
  student.accessed_at = Time.now.utc
  student.save
end
</code></pre>

<p>end</p>

<p>s = Squad.first
s.students &lt;&lt; Student.create(:name => &ldquo;学员&rdquo;)
```</p>

<h2>总结</h2>

<p>学会了这些,可以对数据库更加理解,而且减少代码量(减少自己写数据库查询),优化了代码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rails association]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/10/rails-association/"/>
    <updated>2013-12-10T13:13:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/10/rails-association</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://guides.rubyonrails.org/association_basics.html">rails guides association</a></li>
<li><a href="http://guides.rubyonrails.org/association_basics.html">rails api association</a></li>
<li><a href="http://ihower.tw/rails3/activerecord-relationships.html">rails 实战圣经-资料表关联</a></li>
<li><a href="http://railscasts.com/episodes/154-polymorphic-association">rails polymorphic-association</a></li>
</ul>


<h2>模型关联</h2>

<p>通过关键字(belongs_to, has_many等)把两个<strong>model</strong>(模型)关联起来,下面以我的开发经验和一些源码来解说每个模型关联</p>

<p>所有关键字如下:</p>

<ul>
<li>belongs_to</li>
<li>has_one</li>
<li>has_many</li>
<li>has_many :through</li>
<li>has_one :through</li>
<li>has_and_belongs_to_many</li>
</ul>


<h3>一对多</h3>

<p>通过<strong>has_many</strong>或<strong>has_many :through</strong>或自关联来定义,一个<strong>modelA</strong>有很多<strong>modelB</strong>,那些<strong>modelB</strong>都属于<strong>modelA</strong>例如一篇文章有很多评论, 一个班级有很多学员</p>

<h4>has_many</h4>

<p><img src="/images/rails_association/has_many_and_belongs_to.png"></p>

<!-- more -->


<p>``` ruby
class Comment &lt; ActiveRecord::Base
  belongs_to :artilce
end</p>

<p>class Article &lt; ActiveRecord::Base
  has_many :comments
end
```</p>

<p><strong>comments</strong>表必须要有一个<strong>foreign_key</strong>(article_id)才能实现两个表的关联</p>

<h4>has_many :through</h4>

<p><img src="/images/rails_association/has_many_through_three.png"></p>

<p>``` ruby
class kindergarten &lt; ActiveRecord::Base
  has_many :squads
  has_many :students, :through => :squads
end</p>

<p>class Squad &lt; ActiveRecord::Base
  belongs_to :kindergarten
  has_many :students
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad
end
```</p>

<p>这种方式适用于三层关系(祖,父,孙)的，而且在第三层不用写belongs_to第一层</p>

<h4>自关联(self join)</h4>

<p>foreign_key是可以指定你想要的任何字段,通过foreign_key我们可以实现自关联(Self Joins),即一个表中即定义了has_many又定义了belongs_to,例如<a href="http://yinsigan.github.io/blog/2013/12/09/acts-as-treeyuan-ma-fen-xi/">acts_as_tree</a>就是这样实现的,它是一个树结构,它是这样实现的</p>

<p><code>ruby comment.rb
class Comment &lt; ActiveRecord::Base
  has_many   :children, :class_name =&gt; 'Comment', :foreign_key =&gt; :parent_id
  belongs_to :parent,   :class_name =&gt; 'Comment', :foreign_key =&gt; :parent_id
end
</code></p>

<h3>一对一</h3>

<p>通过<strong>has_one</strong>或<strong>has_one :through</strong>来定义,一个<strong>modelA</strong>有一个<strong>modelB</strong>, 那么<strong>modelB</strong>属于<strong>modelA</strong>,他们之间是一对一的关系,例如一个男人只有一个妻子,一个人只有一个身份证都是现实中一对一的关系</p>

<h4>has_one</h4>

<p><img src="/images/rails_association/has_one_belongs_to.png"></p>

<p>``` ruby
class User &lt; ActiveRecord::Base
  has_one :profile
end</p>

<p>class Profile &lt; ActiveRecord::Base
  belongs_to :user
end
```</p>

<p>一对一的关系也是要通过foreign_key来关联的</p>

<h4>has_one :through</h4>

<p><img src="/images/rails_association/has_one_through.png"></p>

<p>``` ruby
class User &lt; ActiveRecord::Base
  has_one :profile
  has_one :proile_detail, :through => :profile
end</p>

<p>class Profile &lt; ActiveRecord::Base
  belongs_to :user
  has_one :proile_detail
end</p>

<p>class ProfileDetail &lt; ActiveRecord::Base
  belongs_to :profile
end
```</p>

<p>这个<strong>has_one :through</strong>的原理跟<strong>has_many :through</strong>的差不多,都是三级关系</p>

<h3>多对多</h3>

<p>能过<strong>has_many :through</strong>或<strong>has_many_and_belongs_to</strong>来定义,<strong>modelA</strong>有很多<strong>modelB</strong>,<strong>modelB</strong>也有很多<strong>modelA</strong>,它们之间是多对多的关系,例如人有很多的钱,钱属于很多人</p>

<h4>has_many :through</h4>

<p><img src="/images/rails_association/has_many_through.png"></p>

<p>``` ruby
class Staff &lt; ActiveRecord::Base
  has_many :teachers
  has_many :squads, :through => :teachers
end</p>

<p>class Squad &lt; ActiveRecord::Base
  has_many :teachers
  has_many :squads, :through => :teachers
end</p>

<p>class Teacher &lt; ActiveRecord::Base
  belongs_to :squad
  belongs_to :staff
end
```</p>

<p>多对多的实现是要通过中间表的,而has_many :through这种方式的中间表有两个好处,第一个是表名你可以自己随便命名(比较人性化),第二个好处你可以在中间表上加属性</p>

<h4>has_many_and_belongs_to</h4>

<p><img src="/images/rails_association/has_many_and_belongs_to.png"></p>

<p><code>ruby
class Role &lt; ActiveRecord::Base
  has_and_belongs_to_many :operates
end
class Operate &lt; ActiveRecord::Base
  has_and_belongs_to_many :roles
end
</code></p>

<p>这种方式对中间表的命名是有规定的,连中间表的model也不用写,<strong>has_many_and_belongs_to</strong>是rails提供的,缺点是不能灵活控制,优点是方便</p>

<p>在migration创建表不创建id(没必要)</p>

<h3>Polymorphic Associations(多态)</h3>

<p>上述都是两个表进行关联,有的不需要中间表,有的不需要,如果要实现三个表以上的关联呢,这个时候就要用到多态了,例如我们不止在文章里可以加评论,在新闻里也可以评论,在贴子里都可以</p>

<p><img src="/images/rails_association/polymorphic.png"></p>

<p>``` ruby
class Followable &lt; ActiveRecord::Base
  belongs_to :followable, :polymorphic => true
end</p>

<p>class Book &lt; ActiveRecord::Base
  has_many :follow, :as => :followable
end</p>

<p>class User &lt; ActiveRecord::Base
  has_many :follow, :as => :followable
end</p>

<p>class Comment &lt; ActiveRecord::Base
  has_many :follow, :as => :followable
end
```</p>

<p>多态的方法很灵活,它也需要一个中间表,但是他不止能关联一个表,而关联无数个表,在中间表中一个字段是存关联表的类型,一个存id,它通过这两个字段来实现关联所有表的</p>

<h3>单表继承</h3>

<p>有些模型的相似度达到百分之九十,甚至有些只有一个字段的值不同,没必要复制一遍model，再改不同的字段</p>

<p>这个时候可以用一个字段但存的值是不同的,这种方式可以的,只是因为类型不同,数据和逻辑不同,控制器即使写两套，还是要做各种判断,代码会变得很乱,很麻烦</p>

<p>这个时候一个好的解决方案就是用单表继承</p>

<p><img src="/images/rails_association/single_table_inheritance.png"></p>

<p>``` ruby
class GrowthRecord &lt; ActiveRecord::Base
end</p>

<p>class HomeGrowthRecord &lt; GrowthRecord
end</p>

<p>class GardenGrowthRecord &lt; GrowthRecord
end
```</p>

<p>GrowthRecord必须存一个字段叫type:string的,这个是自动处理的</p>

<p>如果不让GrowthRecord被实例化,可以加self.abstract_class = true,这样GrowthRecord就被锁住了</p>

<h2>总结</h2>

<p>学习这些可以让我们对rails association更理解,理解如何设计数据库,处理复杂的逻辑关系</p>
]]></content>
  </entry>
  
</feed>
