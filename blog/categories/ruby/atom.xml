<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | 小子的博客]]></title>
  <link href="http://yinsigan.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://yinsigan.github.io/"/>
  <updated>2013-12-16T23:35:15+08:00</updated>
  <id>http://yinsigan.github.io/</id>
  <author>
    <name><![CDATA[小子]]></name>
    <email><![CDATA[ganweiliang886@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ancestry源码分析]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/14/ancestryyuan-ma-fen-xi/"/>
    <updated>2013-12-14T21:12:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/14/ancestryyuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<ul>
<li><a href="https://github.com/stefankroes/ancestry">ancestry</a></li>
</ul>


<h3>这个gem是做什么的,原理是什么</h3>

<p>这个gem跟<a href="/blog/2013/12/09/acts-as-treeyuan-ma-fen-xi/">acts_as_tree</a>的作用是一样的,不明白的同学可以看这篇<a href="/blog/2013/12/09/acts-as-treeyuan-ma-fen-xi/">blog</a>.而且在这篇blog我们不直接来分析代码,而是通过使用ancestry的功能来分析代码,并作些比较.由于个人感觉这个gem的代码有点老式,会加上我自己认为可以改进的代码.</p>

<h3>架构</h3>

<p><strong>数据库表</strong></p>

<p><img src="/images/ancestry/table.png"></p>

<p><img src="/images/ancestry/table_content.png"></p>

<p>在acts_as_tree中只要一个字段来存父与子的关系,然后用<code>has_many :children</code>和<code>belongs_to :parent</code>,而ancestry也是用一个字段(ancestry),不过它的存取方式跟acts_as_tree是不一样的,它不止存着父的id，还存父的父,也就是说存了祖先的id(62/63),而ancestry_depth存的是层次,类似于祖谱中的辈分,祖先是0(第一代),它的儿子是1(第二代)</p>

<p>在上面的图中,id为62的comment就是root(祖先),它的ancestry是<strong>NULL</strong>,它的ancestry_depth是0</p>

<p>id为64的comment的父为63,63的父为62,所以64的ancestry为62/63</p>

<p>假如在id为64的comment下创建一个子,那这个子的ancestry就为62/63/64</p>

<p>要找64的父也很简单,只要查找一下ancestry这个字段的值,最后一个数字就是了
要找64的祖先也很简单,ancestry的第一个数字就是</p>

<p>ancestry这个gem就是以这种方式来找子和父和存储整个关系的</p>

<p>这种存储方式较act_as_tree的parent_id有更好的先进性</p>

<ul>
<li><strong>查询速度快</strong></li>
</ul>


<p>只存父的id(parent_id)要找祖先的话很麻烦的,只能一层一层往上找,很耗时间</p>

<ul>
<li><strong>查询和操作功能多</strong></li>
</ul>


<p>acts_as_tree只支持几个较简单的查询,查父:parent,查子:children,查祖先:ancestors,查根等</p>

<p>而ancestry支持的查询就很多了,除了上面的,还能查path,children_ids之类的</p>

<p>两者的区别的原因在于实现的方式不一样,acts_as_tree就是通过实例方法来实现的,而ancestry是通过scope
来实现(比较灵活),下面会讲到</p>

<p><strong>源码文件</strong></p>

<p><img src="/images/ancestry/source_tree.png"></p>

<p>只有五个文件</p>

<ul>
<li><strong>ancestry.rb</strong>: 主程序文件,一些require语句</li>
<li><strong>class_methods.rb</strong>: 类方法的集全</li>
<li><strong>instance_methods.rb</strong>: 实例方法的集合</li>
<li><strong>exceptions.rb</strong>: 自定义的例外(关于报错的)</li>
<li><strong>has_ancestry.rb</strong>: 关于has_ancestry这个方法的源码</li>
</ul>


<p>PS:我觉得instance_methods.rb和class_methods.rb还有has_ancestry.rb可以合并在一个文件</p>

<p>然后</p>

<p>``` ruby</p>

<p>module Ancestry
  extend ActiveSupport::Concern</p>

<p>  included do
  end</p>

<p>  module ClassMethods
  # class_methods.rb文件的内容可放于此
  end</p>

<p>  module InstanceMethods
  # instance_methods.rb文件的内容可放于此
  end
end</p>

<p>```</p>

<p>或者</p>

<p>``` ruby
module Ancestry
  def self.included(base)</p>

<pre><code>base.extend ClassMethods
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>def has_ancestry
  ...
  include Ancestry::InstanceMethods
end
</code></pre>

<p>  end</p>

<p>  module InstanceMethods
  end
end
```</p>

<p>而has_ancestry的是这样的</p>

<p>``` ruby
  class &lt;&lt; ActiveRecord::Base # 继承到ActiveRecord::Base都有has_ancestry这个方法哦</p>

<pre><code>def has_ancestry options={}
  # Include instance methods
  include Ancestry::InstanceMethods

  # Include dynamic class methods
  extend Ancestry::ClassMethods
  .......
end
</code></pre>

<p>  end
```</p>

<h3>根据功能来解析代码</h3>

<h4>创建根(root)</h4>

<p>你懂的<code>root = Comment.create</code></p>

<p><img src="/images/ancestry/root.png"></p>

<h4>在根(root)下创建个孩子</h4>

<p><code>first_children = root.children.create</code></p>

<p><img src="/images/ancestry/first_children.png"></p>

<p>在acts_as_tree也可以通过这样的方式来创建子
但在ancestry中是没有<code>has_many children</code>的
猜想一下源码肯定会有一个实例方法叫children(<code>root.children</code>)
即使有这个方法也不能create啊
ancestry用了一个方式来实现,正是scope,可以说很多的查询都是基于它</p>

<p>你肯定用过类似<code>Topic.where(:title =&gt; 'xx').order("created_at DESC").limit(4)</code>这样的方法
就是用的scope</p>

<p>先来看看实例方法<strong>children</strong></p>

<p><code>ruby instance_methods.rb
def children
  self.base_class.scoped :conditions =&gt; child_conditions
end
</code></p>

<p>base_class是什么东西呢</p>

<p>``` ruby has_ancestry.rb
class &lt;&lt; ActiveRecord::Base
  &hellip;
  # Save self as base class (for STI)
  def ancestry options={}</p>

<pre><code># :base_class是个类变量(相当于java中的static变量)
cattr_accessor :base_class
# self就是Comment
self.base_class = self
</code></pre>

<p>  end
  &hellip;
end
```</p>

<p>原来就是引用<strong>Comment</strong>自己嘛</p>

<p>scoped是什么呢,看这里<a href="http://apidock.com/rails/ActiveRecord/NamedScope/ClassMethods/scoped">scoped</a></p>

<p>child_conditions呢</p>

<p>``` ruby instance_methods.rb</p>

<h1>Children</h1>

<h1>改了ancestry值了哦,这个时候对象变"脏"了</h1>

<p>def child_conditions
  {self.base_class.ancestry_column => child_ancestry}
end
```</p>

<p>ancestry_column默认是ancestry,就是数据库那个列名</p>

<p>``` ruby has_ancestry.rb</p>

<h1>Create ancestry column accessor and set to option or default</h1>

<p>cattr_accessor :ancestry_column
self.ancestry_column = options[:ancestry_column] || :ancestry
```</p>

<p>重头戏在<strong>child_ancestry</strong></p>

<p>``` ruby instance_methods.rb</p>

<h1>The ancestry value for this record&rsquo;s children</h1>

<p>def child_ancestry
  # New records cannot have children
  raise Ancestry::AncestryException.new(&lsquo;No child ancestry for new record. Save record before performing tree operations.&rsquo;) if new_record?</p>

<p>  # 这段代码比较长,最佳实践不推荐这样写,应该拆成多行
  # 求原始数据,was
  if self.send(&ldquo;#{self.base_class.ancestry_column}<em>was&rdquo;).blank? then id.to_s else &ldquo;#{self.send &rdquo;#{self.base_class.ancestry_column}</em>was"}/#{id}&ldquo; end
end
```</p>

<p><code>"#{self.base_class.ancestry_column}_was"</code>这是什么东西来的,看这里<a href="http://api.rubyonrails.org/classes/ActiveModel/Dirty.html">Active Model Dirty</a></p>

<p><strong>root</strong>的<strong>ancestry</strong>(root.base_class.ancestry_column)就是<strong>nil</strong>,所以<code>self.base_class_column =&gt; child_ancestry</code>就是<strong>root</strong>的<strong>id.to_s(&ldquo;72&rdquo;)</strong></p>

<p>如果不是root呢,那就是<code>"#{self.send "#{self.base_class.ancestry_column}_was"}/#{id}"</code>,例如如果是first_children,那就是"72/73"</p>

<p>经过<strong>child_conditions</strong>,ancestry的值被改变了,我们通过scoped链过来的build方法看它的改变,所以</p>

<p><img src="/images/ancestry/root_ancestry_changes.png">
<img src="/images/ancestry/first_child_ancestry_changes.png"></p>

<p>这个时候save一下就会将数据保存到数据库中了</p>

<p>看一下几个关于children的方法</p>

<p>``` ruby instance_methods.rb</p>

<h1>查找所有孩子的id</h1>

<p>def child_ids
  # 在rails 3或4中可以用children.pluck(:id)
  children.all(:select => self.base_class.primary_key).map(&amp;self.base_class.primary_key.to_sym)
end</p>

<h1>判断是否有孩子</h1>

<p>def has_children?
  self.children.exists?({})
end</p>

<h1>是否叶子节点(没有孩子)</h1>

<p>def is_childless?
  !has_children?
end
```</p>

<h4>在first_children创建一个siblings(兄弟)节点</h4>

<p><img src="/images/ancestry/siblings_changes.png"></p>

<p>``` ruby instance_methods.rb</p>

<h1>Siblings</h1>

<h1>变成跟自己(first_children)一样的ancestry</h1>

<h1>改ancestry值,对象变"脏"(Dirty)</h1>

<p>def sibling_conditions
  {self.base_class.ancestry_column => read_attribute(self.base_class.ancestry_column)}
end</p>

<h1>返回所有的兄弟节点,是包括自己的(first_children),因为是根据ancestry(父)来查的</h1>

<p>def siblings
  self.base_class.scoped :conditions => sibling_conditions
end</p>

<h1>返回所有的兄弟节点的id</h1>

<p>def sibling_ids
   siblings.all(:select => self.base_class.primary_key).collect(&amp;self.base_class.primary_key.to_sym)
end</p>

<p>def has_siblings?
  self.siblings.count > 1
end</p>

<p>def is_only_child?
  !has_siblings?
end
```</p>

<p>如果不让siblings包含自己,只要<code>first_children.siblings - [first_children]</code>就行了</p>

<h4>指定父(parent)节点创建一个Comment</h4>

<p>在comment.rb的白名单上加 <code>attr_accessible :parent</code></p>

<p><img src="/images/ancestry/create_with_parent.png"></p>

<p>既然可以指定<strong>parent</strong>,那一定有<code>parent=()</code>这个方法</p>

<p>``` ruby instance_methods.rb</p>

<h1>Parent</h1>

<h1>找到父那个对象再去找父的child_ancestry,即假如父为根就是它的id&hellip;</h1>

<p>def parent= parent
  write_attribute(self.base_class.ancestry_column, if parent.blank? then nil else parent.child_ancestry end)
end</p>

<h1>还是会执行paren= parent方法</h1>

<p>def parent_id= parent_id
  self.parent = if parent_id.blank? then nil else self.base_class.find(parent_id) end
end</p>

<h1>返回祖先链的最后一个id,即父的id,ancestors下面会讲到</h1>

<p>def parent_id
  if ancestor_ids.empty? then nil else ancestor_ids.last end
end</p>

<h1>用id找到那个parent,找不到就是nil</h1>

<p>def parent
  if parent_id.blank? then nil else self.base_class.find(parent_id) end
end
```</p>

<h4>查找刚创建的第三代的祖先链</h4>

<p><img src="/images/ancestry/ancestor_search.png"></p>

<p>``` ruby instance_methods.rb</p>

<h1>Ancestors</h1>

<h1>读取ancestry的值split后组成数组,取变量的值没有查数据库</h1>

<p>def ancestor_ids
  read_attribute(self.base_class.ancestry_column).to_s.split(&lsquo;/&rsquo;).map { |id| cast_primary_key(id) }
end</p>

<h1>把ancestor_ids数组传给id</h1>

<p>def ancestor_conditions
  {self.base_class.primary_key => ancestor_ids}
end</p>

<p>def ancestors depth_options = {}
  self.base_class.scope_depth(depth_options, depth).ordered_by_ancestry.scoped :conditions => ancestor_conditions
end</p>

<p>def path_ids
  ancestor_ids + [id]
end</p>

<p>def path_conditions
  {self.base_class.primary_key => path_ids}
end</p>

<p>def path depth_options = {}
  self.base_class.scope_depth(depth_options, depth).ordered_by_ancestry.scoped :conditions => path_conditions
end
```</p>

<p><strong>scope_depth</strong>是个类方法,看它之前先来看看架构那部分那里,表据表除了有个<strong>ancestry</strong>字段,还有<strong>ancestry_depth</strong>这个字段</p>

<p>这个<strong>ancestry_depth</strong>就是类变量<strong>depth_cache_column</strong>定义的</p>

<p>``` ruby has_ancestry.rb</p>

<h1>Create ancestry column accessor and set to option or default</h1>

<p>if options[:cache_depth]
  # Create accessor for column name and set to option or default
  self.cattr_accessor :depth_cache_column
  self.depth_cache_column = options[:depth_cache_column] || :ancestry_depth</p>

<p>  # Cache depth in depth cache column before save
  # 验证depth_cache_column必须是整数且大于或等于0
  before_validation :cache_depth</p>

<p>  # Validate depth column
  validates_numericality_of depth_cache_column, :greater_than_or_equal_to => 0, :only_integer => true, :allow_nil => false
end</p>

<h1>Create named scopes for depth</h1>

<h1>下面就是一个条件,跟ancestry_depth比,例如before_depth就是'&ldquo;ancestry_depth &lt; ?&rdquo;, 3'之类的</h1>

<p>{:before_depth => &lsquo;&lt;&rsquo;, :to_depth => &lsquo;&lt;=&rsquo;, :at_depth => &lsquo;=&rsquo;, :from_depth => &lsquo;>=&rsquo;, :after_depth => &lsquo;>&rsquo;}.each do |scope_name, operator|
  # send scope_method就是定义一个scope
  send scope_method, scope_name, lambda { |depth|</p>

<pre><code>raise Ancestry::AncestryException.new("Named scope '#{scope_name}' is only available when depth caching is enabled.") unless options[:cache_depth]
{:conditions =&gt; ["#{depth_cache_column} #{operator} ?", depth]}
</code></pre>

<p>  }
end
```
<img src="/images/ancestry/scope_depth.png"></p>

<p>为什么数字会改变呢,原来那个<strong>before_depth</strong>不是基于<strong>root</strong>(根),而是基于<strong>c</strong>(孙),<strong>c</strong>有两个前辈1+1=2,所以数据库查的是2+2=4</p>

<p>``` ruby class_methods.rb解读scope_depth
def ancestors depth_options = {}
  self.base_class.scope_depth(depth_options, depth).ordered_by_ancestry.scoped :conditions => ancestor_conditions
end</p>

<h1>也就是自己ancestry_depth的值</h1>

<p>def depth
  ancestor_ids.size
end</p>

<p>def scope_depth depth_options, depth
  # inject方法很灵活
  depth_options.inject(self.base_class) do |scope, option|</p>

<pre><code># relative_depth是传进来的值
scope_name, relative_depth = option
if [:before_depth, :to_depth, :at_depth, :from_depth, :after_depth].include? scope_name
  # ancestry_depth的值加上传进来的值
  scope.send scope_name, depth + relative_depth
else
  raise Ancestry::AncestryException.new("Unknown depth option: #{scope_name}.")
end
</code></pre>

<p>  end
end</p>

<p>scope_method = if rails_3 then :scope else :named_scope end</p>

<h1>很多方法用到这个,在rails 3中会变成send :scope, :ordered_by_ancestry&hellip;</h1>

<h1>如果是根会排在前面</h1>

<p>send scope_method, :ordered_by_ancestry, :order => &ldquo;(case when #{table_name}.#{ancestry_column} is null then 0 else 1 end), #{table_name}.#{ancestry_column}&rdquo;
```</p>

<h4>其他几个查询方法</h4>

<p>主要是<strong>subtree</strong>和<strong>root</strong></p>

<p>``` ruby</p>

<h1>Subtree</h1>

<h1>包括自己查后代,使用self.id, child_ancestry是查自己的子,&ldquo;#{child_ancestry}/"查孙一代起</h1>

<p>def subtree_conditions
  [&ldquo;#{self.base_class.table_name}.#{self.base_class.primary_key} = ? or #{self.base_class.table_name}.#{self.base_class.ancestry_column} like ? or #{self.base_class.table_name}.#{self.base_class.ancestry_column} = ?&rdquo;, self.id, &ldquo;#{child_ancestry}/%&rdquo;, child_ancestry]
end</p>

<p>def subtree depth_options = {}
  self.base_class.ordered_by_ancestry.scope_depth(depth_options, depth).scoped :conditions => subtree_conditions
end</p>

<p>def subtree_ids depth_options = {}
  subtree(depth_options).all(:select => self.base_class.primary_key).collect(&amp;self.base_class.primary_key.to_sym)
end</p>

<h1>Root</h1>

<h1>返回根的id,在acts_as_tree可是要遍历的,这个就简单多了</h1>

<h1>ancestor_ids是空的,那就返回自己的id</h1>

<p>def root_id
  if ancestor_ids.empty? then id else ancestor_ids.first end
end</p>

<h1>如果根就是自己,那就不用查了</h1>

<p>def root
  if root_id == id then self else self.base_class.find(root_id) end
end</p>

<h1>判断是不是nil而已</h1>

<p>def is_root?
  read_attribute(self.base_class.ancestry_column).blank?
end
```</p>

<h4>将第三代c的父改为根(root),变成了第二代</h4>

<p>第三代要变成第二代,把ancestry改为第一代的id,ancestry_depth从2变成1即可</p>

<p><strong>但是</strong>第三代也有后代,而且可能有很多(第四代,第五代&hellip;),他们怎么办</p>

<p>改变前:</p>

<p><img src="/images/ancestry/before_change_parent.png"></p>

<p><img src="/images/ancestry/change_parent.png"></p>

<p>改变后:</p>

<p><img src="/images/ancestry/after_change_parent.png"></p>

<p>先来看看ancestry的变化</p>

<p>他的后代的ancestry的变化是通过<strong>before_save</strong>来实现的</p>

<p>在<strong>before_save</strong>之前c(77)的ancestry最先变化,它由"72/73"变成了"72"</p>

<p>看上面那个命令图,第一个改的后代是id为78(c的子)那个
它由"72/73/77"变成"72/77"</p>

<p>id为79(c的孙)那个Comment的ancestry由"72/73/77/78"变成"72/77/78"</p>

<p>看出一个规律就是把"72/73"变成"72"罢了,其他的不变,因为c的ancestry由"72/73"变成了"72",所以它的后代跟着变</p>

<p>如果上面推测正确,那么&hellip;</p>

<p>``` ruby has_ancestry.rb</p>

<h1>Update descendants with new ancestry before save</h1>

<p>before_save :update_descendants_with_new_ancestry
```</p>

<p>``` ruby instance_methods.rb</p>

<h1>Descendants</h1>

<h1>查的是所有后代,下面的update_descendants_with_new_ancestry会用到</h1>

<p>def descendant_conditions
  [&ldquo;#{self.base_class.table_name}.#{self.base_class.ancestry_column} like ? or #{self.base_class.table_name}.#{self.base_class.ancestry_column} = ?&rdquo;, &ldquo;#{child_ancestry}/%&rdquo;, child_ancestry]
end</p>

<p>def descendants depth_options = {}
  self.base_class.ordered_by_ancestry.scope_depth(depth_options, depth).scoped :conditions => descendant_conditions
end</p>

<h1>在外面包装一个scope</h1>

<p>def unscoped_descendants
  # with_exclusive_scope就是with_scope,不明白的可以看<a href="http://apidock.com/rails/ActiveRecord/Base/with_scope/class">http://apidock.com/rails/ActiveRecord/Base/with_scope/class</a>
  self.base_class.send(:with_exclusive_scope) do</p>

<pre><code>self.base_class.all(:conditions =&gt; descendant_conditions)
</code></pre>

<p>  end
end</p>

<h1>Update descendants with new ancestry</h1>

<p>def update_descendants_with_new_ancestry
  # Skip this if callbacks are disabled
  # ancestry_callbacks_disabled?是一个开关,为了让下面的更改有序的进行而不发生数据更改的碰撞,可以看下面相关的代码
  unless ancestry_callbacks_disabled?</p>

<pre><code># If node is valid, not a new record and ancestry was updated ...
# ancestry_column肯定先改变啦,那就那个c的值啦,!new_reocrd?也肯定不是新数据啦,必须要是有效的valid?(验证通过)
if changed.include?(self.base_class.ancestry_column.to_s) &amp;&amp; !new_record? &amp;&amp; valid?
  # ... for each descendant ...
  # 会去循环每个后代哦
  unscoped_descendants.each do |descendant|
    # ... replace old ancestry with new ancestry
    # 进行有without_ancestry_callbacks的代码,里面包装的是一个原子操作,防止数据被错误修改
    descendant.without_ancestry_callbacks do
      # 更改ancestry的值哦
      descendant.update_attribute(
        # 就是ancestry那个列嘛
        self.base_class.ancestry_column,
        # 读取每个后代ancestry的值,gsub进行全局替换
        descendant.read_attribute(descendant.class.ancestry_column).gsub(
          # child_ancestry是没变之前的ancestry的值,例如上例中的c的ancestry值"72/73"
          /^#{self.child_ancestry}/,
          # self就是c,替换成c现有的值,也就是"72"
          if read_attribute(self.class.ancestry_column).blank? then id.to_s else "#{read_attribute self.class.ancestry_column }/#{id}" end
        )
      )
    end
  end
end
</code></pre>

<p>  end
end</p>

<h1>开关控制</h1>

<h1>Callback disabling</h1>

<p>def without_ancestry_callbacks
  @disable_ancestry_callbacks = true
  yield
  @disable_ancestry_callbacks = false
end</p>

<p>def ancestry_callbacks_disabled?
  !!@disable_ancestry_callbacks
end
```</p>

<p>代码果然如我们预期的效果一样</p>

<p>接下来我们来看看ancestry_depth的变化</p>

<p>说到这个必须谈下<code>has_ancestry :cache_depth =&gt; true</code></p>

<p><code>:cache_depth =&gt; true</code>开启了之后就可以在<strong>ancestry_depth</strong>(默认)存树的深度,root为0,第一代为1</p>

<p>``` ruby has_ancestry.rb</p>

<h1>Create ancestry column accessor and set to option or default</h1>

<p>if options[:cache_depth]
  &hellip;
  # Cache depth in depth cache column before save
  # 在验证之前会执行这个的
  before_validation :cache_depth
  &hellip;
end
```</p>

<p>:cache_depth到底做了什么事儿</p>

<p>``` ruby</p>

<h1>求深度,例如,ancestry为'72/73'的深度就是'2'(第三代)</h1>

<p>def depth
  ancestor_ids.size
end</p>

<h1>write_attribute是save(false)的,更改ancestry_depth的值</h1>

<p>def cache_depth
  write_attribute self.base_class.depth_cache_column, depth
end
```</p>

<p>在改descendant时根本没有改它的<strong>ancestry_depth</strong>,所以descendant的ancestry_depth没有即时更新,跟我们预期的结果不一样</p>

<p>只要重载<strong>update_descendants_with_new_ancestry</strong>方法</p>

<p>加上下面的代码就可以解决那个问题了</p>

<p>``` ruby
def update_descendants_with_new_ancestry
  &hellip;
  descendant.update_attribute(</p>

<pre><code>self.base_class.ancestry_column,
descendant.read_attribute(descendant.class.ancestry_column).gsub(
  /^#{self.child_ancestry}/,
  if read_attribute(self.class.ancestry_column).blank? then id.to_s else "#{read_attribute self.class.ancestry_column }/#{id}" end
)
</code></pre>

<p>  )
  # 加入下面的代码哦
  descendant.reload
  descendant.update_attribute(</p>

<pre><code>self.base_class.depth_cache_column,
descendant.depth
</code></pre>

<p>  )
  &hellip;
end
```</p>

<h4>删除c(有后代)</h4>

<p>删除一个Comment很简单,只要把那条记录删除就行了,但是删除后它的后代怎么办</p>

<p>ancestry是通过:orphan_strategy这个参数来控制,而has_ancestry.rb有这句<code>before_destroy :apply_orphan_strategy</code></p>

<p>:orphan_strategy只有三个值: :rootify, :destroy, :restrict</p>

<p>先看下:rootify</p>

<p>改变前:</p>

<p><img src="/images/ancestry/destroy_rootify.png"></p>

<p>改变后:</p>

<p><img src="/images/ancestry/after_destroy_rootify.png"></p>

<p>c被删除后,它的子(81)没有了父,就把ancestry设为NULL,它自己的子(82)的ancestry还是指向自己(81),依此类推&hellip;</p>

<p>其实做的就是把id为82的comment的ancestry:&ldquo;72/73/80/81"的"72/73/80&rdquo;(81的ancestry,也就是c.child_ancestry)删除掉</p>

<p>:destroy就不做这些改变了,直接删除数据</p>

<p>:restrict,只要有后代就抛出异常</p>

<p>来看下代码</p>

<p>``` ruby</p>

<h1>Apply orphan strategy</h1>

<p>def apply_orphan_strategy
  # Skip this if callbacks are disabled
  unless ancestry_callbacks_disabled?</p>

<pre><code># If this isn't a new record ...
unless new_record?
  # ... make all children root if orphan strategy is rootify
  if self.base_class.orphan_strategy == :rootify
    unscoped_descendants.each do |descendant|
      descendant.without_ancestry_callbacks do
        # descendant.ancestry == child_ancestry就是c的子,直接设为NULL
        # 从c的"孙"开始,把ancestry的值前面一部分替换掉,也就是子的ancestry,所有孙之后的后代的这部分都替换成空
        descendant.update_attribute descendant.class.ancestry_column, (if descendant.ancestry == child_ancestry then nil else descendant.ancestry.gsub(/^#{child_ancestry}\//, '') end)
      end
    end
  # ... destroy all descendants if orphan strategy is destroy
  elsif self.base_class.orphan_strategy == :destroy
    unscoped_descendants.each do |descendant|
      descendant.without_ancestry_callbacks do
        # 直接删除后代
        descendant.destroy
      end
    end
  # ... throw an exception if it has children and orphan strategy is restrict
  elsif self.base_class.orphan_strategy == :restrict
    # 抛出异常
    raise Ancestry::AncestryException.new('Cannot delete record because it has descendants.') unless is_childless?
  end
end
</code></pre>

<p>  end
end
```</p>

<h3>总结</h3>

<ol>
<li>通过这个gem我们可以学习比较先进的数据库设计的理念,就是减少数据库的查询次数</li>
<li>学习scope的灵活用法</li>
<li>高效查询算法的设计</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Association Reference]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/11/rails-association-reference/"/>
    <updated>2013-12-11T10:09:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/11/rails-association-reference</id>
    <content type="html"><![CDATA[<h2>rails关联模型参数的使用</h2>

<p>上一篇<a href="http://yinsigan.github.io/blog/2013/12/10/rails-association/">rails association</a>说明了rails的各种模型的原理和设计,这篇我们来说说rails association具体参数的使用,通过一些案例或代码来分析它们的使用场景</p>

<p><img src="/images/rails_association_reference/has_many_through.png"></p>

<p>``` ruby
class School &lt; ActiveRecord::Base
  has_many :squads
  has_many :students, :through => :squads
end</p>

<p>class Squad &lt; ActiveRecord::Base
  belongs_to :school
  has_many :students
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad
end
```</p>

<h3>Association(关联关系的使用)</h3>

<ul>
<li>association(force_reload = false)强制reload查数据库</li>
</ul>


<!-- more -->


<p>``` ruby
s = Squad.first
s.students
=> [#<Student id: 40, name: "学员1", squad_id: 1, created_at: "2013-12-11 02:43:53", updated_at: "2013-12-11 02:43:53", active: true>,
 #<Student id: 41, name: "学员2", squad_id: 1, created_at: "2013-12-11 02:43:56", updated_at: "2013-12-11 02:43:56", active: true>]</p>

<p>s.students.last.delete #把最后一个学员删除,那班级s只剩下一个学员</p>

<h1>可是还是两个学员</h1>

<p>s.students
=> [#<Student id: 40, name: "学员1", squad_id: 1, created_at: "2013-12-11 02:43:53", updated_at: "2013-12-11 02:43:53", active: true>,
 #<Student id: 41, name: "学员2", squad_id: 1, created_at: "2013-12-11 02:43:56", updated_at: "2013-12-11 02:43:56", active: true>]</p>

<h1>如果传入一个参数true</h1>

<p>s.students(true)
=> [#<Student id: 40, name: "学员1", squad_id: 1, created_at: "2013-12-11 02:43:53", updated_at: "2013-12-11 02:43:53", active: true>]
```</p>

<p>其实传入true就是去数据库查询,不直接从变量(<strong>s.students</strong>)取值
<code>
Student Load (0.8ms)  SELECT `students`.* FROM `students` WHERE `students`.`squad_id` = 1 AND `students`.`active` = 1
</code></p>

<ul>
<li>association=(associate)</li>
</ul>


<p>``` ruby</p>

<h1>good</h1>

<p>s = Student.first
s.squad = Squad.last
s.save</p>

<h1>bad</h1>

<p>s.squad_id = &lsquo;9&rsquo;.to_i
s.save
```</p>

<p>这种方式有两个好处,第一个,你不在白名单(attr_accessible)写上:squad_id,第二个你能保证squad_id就是正确存在的吗</p>

<p>最佳实践也是推鉴这种方式的</p>

<p><code>ruby
current_user.posts.build(params[:post])
</code></p>

<ul>
<li>collection&lt;&lt;(object, …)创建记录</li>
</ul>


<p>这是我们创建记录的主要手段之一</p>

<p><code>ruby
s = Squad.first
s.students &lt;&lt; Student.create(:name =&gt; "学员")
</code></p>

<ul>
<li>collection.delete(object, …)删除关联关系(不删除记录)</li>
</ul>


<p><code>`` ruby
s = Squad.first
s.students.delete(s.students.last) #删除最后一条,只是把值设为NULL
=&gt; SQL (0.6ms)  UPDATE</code>students<code>SET</code>squad_id<code>= NULL WHERE</code>students<code>.</code>squad_id<code>= 1 AND</code>students<code>.</code>active<code>= 1 AND</code>students<code>.</code>id` IN (43)</p>

<p>```</p>

<p>delete_all不用传参数就可以删除所有关联关系了</p>

<p>要保留数据的时候又要去掉关联关系用这种方式最好了</p>

<ul>
<li>collection.delete(object, …)删除记录</li>
</ul>


<p>``` ruby
s = Squad.first
st = s.first
s.students.destroy(st)</p>

<h1>是真正的删除记录</h1>

<p>DELETE FROM <code>students</code> WHERE <code>students</code>.<code>id</code> = 46</p>

<p>```</p>

<p>destroy_all不用传参数就可以删除所有关联的记录了</p>

<ul>
<li>collection_singular_ids=ids(更改关联关系)</li>
</ul>


<p>``` ruby
s = Squad.first</p>

<p>s.student_ids
=> [42, 43]</p>

<p>s.students_ids = [40, 43]</p>

<h1>会查一遍数据表students,没有的id你可别乱来哦</h1>

<p>Student Load (0.8ms)  SELECT <code>students</code>.* FROM <code>students</code> WHERE <code>students</code>.<code>id</code> IN (40, 43)</p>

<h1>不要42了就把关联关系去掉(设为NULL)</h1>

<p>SQL (0.6ms)  UPDATE <code>students</code> SET <code>squad_id</code> = NULL WHERE <code>students</code>.<code>squad_id</code> = 1 AND <code>students</code>.<code>active</code> = 1 AND <code>students</code>.<code>id</code> IN (42)</p>

<h1>把40加进去</h1>

<p>UPDATE <code>students</code> SET <code>squad_id</code> = 1, <code>updated_at</code> = &lsquo;2013-12-11 03:19:40&rsquo; WHERE <code>students</code>.<code>id</code> = 40</p>

<p>```</p>

<p>从表单的复选框传来的数据用这种方式解决最好了</p>

<p>最佳实践就是这么做滴</p>

<p>``` ruby 多角色管理
&lt;% for role in Role.all %></p>

<div>
  <%= check_box_tag "user[role_ids][]", role.id, @user.roles.include?(role) %>
  <%=h role.name %>
</div>


<p>&lt;% end %>
&lt;%= hidden_field_tag &ldquo;user[role_ids][]&rdquo;, &ldquo;&rdquo; %>
```</p>

<ul>
<li>collection.clear会把所有关联关系清除或者删掉</li>
</ul>


<p>``` ruby
s = Squad.first
s.students.clear</p>

<h1>只是把关联关系清除而已</h1>

<p>UPDATE <code>students</code> SET <code>squad_id</code> = NULL WHERE <code>students</code>.<code>squad_id</code> = 1 AND <code>students</code>.<code>active</code> = 1 AND <code>students</code>.<code>id</code> IN (42, 42)</p>

<p>```</p>

<p>如果不止想关联关系清除呢,那个就是要在has_many时加入:dependent => :destroy就可以了</p>

<p>其实看下clear的源码就知道原理</p>

<p>``` ruby</p>

<h1>File activerecord/lib/active_record/associations/association_collection.rb, line 244</h1>

<p>def clear
  return self if length.zero? # forces load_target if it hasn&rsquo;t happened already</p>

<p>  if @reflection.options[:dependent] &amp;&amp; @reflection.options[:dependent] == :destroy</p>

<pre><code>destroy_all
</code></pre>

<p>  else</p>

<pre><code>delete_all
</code></pre>

<p>  end</p>

<p>  self
end
```</p>

<ul>
<li>collection.exists?判断记录是否存在</li>
</ul>


<p>``` ruby
s = Squad.first</p>

<p>s.students.exists?(42)
=> true</p>

<p>s.students.exists?(Student.first)
=> true</p>

<p>s.students.exists?(:id => 42)
=> true
```</p>

<p>用<strong>exists?</strong>来判断比<strong>include?</strong>更灵活,<strong>include?</strong>只支持类似这样<code>inlcude?(Student.first)</code>的判断</p>

<h3>Association Parameter Reference(参数的使用)</h3>

<p>有些参数在上一篇<a href="http://yinsigan.github.io/blog/2013/12/10/rails-association/">rails association</a>已经提及过，例如polymorphic, :through等,这里再阐述几个比较常用或用处比较大的</p>

<ul>
<li>class_name</li>
</ul>


<p>查找实际的类名(model)</p>

<p>``` ruby</p>

<h1>默认情况下是:students的,如果要换个名字,就要指定实际的class_name</h1>

<p>has_many :newest_students, :class_name => &lsquo;Student&rsquo;, :order => &lsquo;created_at DESC&rsquo;</p>

<p>SELECT <code>students</code>.* FROM <code>students</code> WHERE <code>students</code>.<code>squad_id</code> = 1 ORDER BY created_at DESC
```</p>

<ul>
<li>conditions</li>
</ul>


<p>指定查询条件</p>

<p><code>ruby
has_many :students, :conditions =&gt; "active = 1"
</code></p>

<p>在rails 4已经用where代替conditions了</p>

<p>conditions有个要注意的地方</p>

<p><code>:conditions =&gt; "active = 1"</code>和<code>{active: true}</code>(Hash)是不一样的
当你用s.students.create或s.students.build创建student的时候,active的值会不一样
用<code>{active: true}</code>形式创建时不管你的active的默认值是否是true，创建的student的active都是true
而<code>:conditions =&gt; "active = 1"</code>就是看active的默认值</p>

<p>:conditions也可以接proc:<code>:conditions =&gt; proc { ["orders.created_at &gt; ?", 10.hours.ago] }</code></p>

<p>实际项目的代码如下:</p>

<p><code>ruby
class School &lt; ActiveRecord::Base
  has_many :students, :include =&gt; :user, :order =&gt; "users.name DESC", :conditions =&gt; "users.tp = 0"
  has_many :staff_users, :class_name =&gt; "User", :order =&gt; :name, :conditions =&gt; "tp = 1"
  has_many :staffs, :through =&gt; :users, :order =&gt; "users.name DESC", :conditions =&gt; "users.tp = 1"
end
</code></p>

<ul>
<li>counter_cache</li>
</ul>


<p>在数据库中记录孩子的数量</p>

<p><code>bash
rails g migration add_students_count_to_squads students_count:integer
</code></p>

<p>``` ruby
class AddStudentsCountToSquads &lt; ActiveRecord::Migration
  def change</p>

<pre><code>add_column :squads, :students_count, :string
Squad.reset_column_information
Squad.find_each do |p|
  Squad.update_counters p.id, :students_count =&gt; p.students.length
end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad, :counter_cache => true
end
```</p>

<p>默认的字段名是跟关联(has_many)的model是一致的,在上述的例子中就是<strong>students_count</strong>,如果想改变这个name也可以,给:counter_cache指定值就可以了,例如<code>:counter_cache =&gt; :children_count</code></p>

<p>当删除关联关系时(squad_id设为NULL)时,students_count不会更新</p>

<ul>
<li>dependent</li>
</ul>


<p>依赖性</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students, :dependent => :destroy
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad
end
```</p>

<p>如果传入<code>:dependent =&gt; :nullify</code>不删除数据,只删除关联数据</p>

<ul>
<li>foreign_key</li>
</ul>


<p>外键</p>

<p><code>ruby
class Topic &lt; ActiveRecord::Base
  belongs_to :creater, :class_name =&gt; 'User', :foreign_key =&gt; "creater_id"
end
</code></p>

<p>当你的model name跟foreign_key不一致时就可以手动指定关联的foreign_key
这样写当<code>topic.creater.try(:name)</code>就可以简单取得创建者的name了</p>

<ul>
<li>include</li>
</ul>


<p>包含查询</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad, :include => :school
end</p>

<p>class School &lt; ActiveRecord::Base
  has_many :squads
end</p>

<p>s = Student.first
s.squad</p>

<h1>查了schools这个表,把数据一并取了出来</h1>

<p>Squad Load (0.3ms)  SELECT <code>squads</code>.<em> FROM <code>squads</code> WHERE <code>squads</code>.<code>id</code> = 14 LIMIT 1
School Load (0.3ms)  SELECT <code>schools</code>.</em> FROM <code>schools</code> WHERE <code>schools</code>.<code>id</code> IN (1)</p>

<h1>前面已经查了schools的数据了,现在不会查sql的</h1>

<p>s.squad.school
```</p>

<p>当你要查<code>Student.first.squad.school</code>就方便多了</p>

<ul>
<li>touch</li>
</ul>


<p>当子类被创建或更改时,更新父类的updated_at</p>

<p>``` ruby
class Student &lt; ActiveRecord::Base
  belongs_to :squad, :touch => true
end</p>

<p>class Squad &lt; ActiveRecord::Base
  has_many :students
end</p>

<p>s = Student.first
s.name = &lsquo;学员&rsquo;
s.save</p>

<h1>其实就是把父的updated_at更新了一下</h1>

<p>UPDATE <code>students</code> SET <code>name</code> = &lsquo;3333333333333&rsquo;, <code>updated_at</code> = &lsquo;2013-12-11 14:59:47&rsquo; WHERE <code>students</code>.<code>id</code> = 86
Squad Load (0.6ms)  SELECT <code>squads</code>.* FROM <code>squads</code> WHERE <code>squads</code>.<code>id</code> = 14 LIMIT 1
SQL (0.7ms)  UPDATE <code>squads</code> SET <code>updated_at</code> = &lsquo;2013-12-11 14:59:47&rsquo; WHERE <code>squads</code>.<code>id</code> = 14
```</p>

<p>如果不想更新updated_at, 还可以指定更新具体的column,例如<code>:touch =&gt; :accessed_at</code></p>

<ul>
<li>validate</li>
</ul>


<p>跳过验证</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students, :validate => true
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad
  validates :name, :presence => true
end</p>

<h1>failure</h1>

<p>Student.create</p>

<h1>success</h1>

<p>s = Squad.first
s.students.create
```</p>

<p>在创建子对象时,可以跳过验证</p>

<ul>
<li>source</li>
</ul>


<p>指定查找源, 和has_one :through或has_many :through一起使用</p>

<p>``` ruby
class School &lt; ActiveRecord::Base
  has_many :squads
  has_many :squads_teachers, :through => :squads, :source => :teachers
end</p>

<p>class Squad &lt; ActiveRecord::Base
  has_many :teachers
  belongs_to :school
end</p>

<p>class Teacher &lt; ActiveRecord::Base
  belongs_to :squad
  belongs_to :staff
end</p>

<p>s = School.first
s.squads_teachers</p>

<h1>查找的是teachers表,不过teachers去joins squads表</h1>

<p>School Load (1.5ms)  SELECT <code>schools</code>.<em> FROM <code>schools</code> LIMIT 1
Teacher Load (90.0ms)  SELECT <code>teachers</code>.</em> FROM <code>teachers</code> INNER JOIN <code>squads</code> ON <code>teachers</code>.<code>squad_id</code> = <code>squads</code>.<code>id</code> WHERE <code>squads</code>.<code>school_id</code> = 1</p>

<h1>grades belongs_to staff</h1>

<p>has_many :grade_teachers, :through => :grades, :source => :staff  #年级组长
```</p>

<p>这种方式用得好真的好灵活</p>

<ul>
<li>group</li>
</ul>


<p>分组</p>

<p>``` ruby
class School &lt; ActiveRecord::Base
  has_many :students, :through => :squads, :group => &lsquo;squads.id&rsquo;
end</p>

<p>s = School.first
s.students</p>

<h1>原理就是在数据库查询的时候加个分组group</h1>

<p>Student Load (81.7ms)  SELECT <code>students</code>.* FROM <code>students</code> INNER JOIN <code>squads</code> ON <code>students</code>.<code>squad_id</code> = <code>squads</code>.<code>id</code> WHERE <code>squads</code>.<code>school_id</code> = 1 GROUP BY squads.id
```</p>

<ul>
<li>:uniq</li>
</ul>


<p>确保查到的数据是唯一的</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :staffs, :through => :teachers, :uniq => true
  has_many :teachers
end</p>

<p>class Staff &lt; ActiveRecord::Base
  has_many :squad, :through => :teachers
  has_many :teachers
end</p>

<p>class Teacher &lt; ActiveRecord::Base
  belongs_to :squad
  belongs_to :staff
end</p>

<p>s = Squad.first
staff = Staff.create
s.staff &lt; staff
s.staff &lt; staff</p>

<h1>如果没有:unqi => true,将会输出多个staffs,数据库也是存在的(相同的数据),加上:unqi => true将只会输出一条数据,这样才符合逻辑</h1>

<p>s.staff</p>

<h1>如果不加这个:uniq => true,这样也可以实现同样的目的</h1>

<p>s.staff.uniq</p>

<p>```</p>

<p>在rails 4用-> { distinct }</p>

<ul>
<li><p>除了这些参数还有<strong>:readonly</strong>, <strong>:order</strong>, <strong>:select</strong>, <strong>:limit</strong>, <strong>:offset</strong>等</p></li>
<li><p>最后来个复杂的项目实例</p></li>
</ul>


<p>``` ruby
class Relationship &lt; ActiveRecord::Base
  belongs_to :follower, class_name: &ldquo;User&rdquo;
  belongs_to :followed, class_name: &ldquo;User&rdquo;
end</p>

<p>class User &lt; ActiveRecord::Base
  has_many :relationships, foreign_key: &ldquo;follower_id&rdquo;, dependent: :destroy
  has_many :followed_users, through: :relationships, source: :followed
  has_many :reverse_relationships, foreign_key: &ldquo;followed_id&rdquo;,</p>

<pre><code>                               class_name:  "Relationship",
                               dependent:   :destroy
</code></pre>

<p>  has_many :followers, through: :reverse_relationships, source: :follower
end
```</p>

<h3>Association Callbacks</h3>

<ul>
<li>before_add 添加前</li>
<li>after_add 添加后</li>
<li>before_remove 删除前</li>
<li>after_remove  删除后</li>
</ul>


<p>这是关联关系的Callbacks</p>

<p>``` ruby
class Squad &lt; ActiveRecord::Base
  has_many :students, :after_add => :update_accessed_at</p>

<p>  private</p>

<pre><code>def update_accessed_at(student)
  student.accessed_at = Time.now.utc
  student.save
end
</code></pre>

<p>end</p>

<p>s = Squad.first
s.students &lt;&lt; Student.create(:name => &ldquo;学员&rdquo;)
```</p>

<h2>总结</h2>

<p>学会了这些,可以对数据库更加理解,而且减少代码量(减少自己写数据库查询),优化了代码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[rails association]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/10/rails-association/"/>
    <updated>2013-12-10T13:13:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/10/rails-association</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://guides.rubyonrails.org/association_basics.html">rails guides association</a></li>
<li><a href="http://guides.rubyonrails.org/association_basics.html">rails api association</a></li>
<li><a href="http://ihower.tw/rails3/activerecord-relationships.html">rails 实战圣经-资料表关联</a></li>
<li><a href="http://railscasts.com/episodes/154-polymorphic-association">rails polymorphic-association</a></li>
</ul>


<h2>模型关联</h2>

<p>通过关键字(belongs_to, has_many等)把两个<strong>model</strong>(模型)关联起来,下面以我的开发经验和一些源码来解说每个模型关联</p>

<p>所有关键字如下:</p>

<ul>
<li>belongs_to</li>
<li>has_one</li>
<li>has_many</li>
<li>has_many :through</li>
<li>has_one :through</li>
<li>has_and_belongs_to_many</li>
</ul>


<h3>一对多</h3>

<p>通过<strong>has_many</strong>或<strong>has_many :through</strong>或自关联来定义,一个<strong>modelA</strong>有很多<strong>modelB</strong>,那些<strong>modelB</strong>都属于<strong>modelA</strong>例如一篇文章有很多评论, 一个班级有很多学员</p>

<h4>has_many</h4>

<p><img src="/images/rails_association/has_many_and_belongs_to.png"></p>

<!-- more -->


<p>``` ruby
class Comment &lt; ActiveRecord::Base
  belongs_to :artilce
end</p>

<p>class Article &lt; ActiveRecord::Base
  has_many :comments
end
```</p>

<p><strong>comments</strong>表必须要有一个<strong>foreign_key</strong>(article_id)才能实现两个表的关联</p>

<h4>has_many :through</h4>

<p><img src="/images/rails_association/has_many_through_three.png"></p>

<p>``` ruby
class kindergarten &lt; ActiveRecord::Base
  has_many :squads
  has_many :students, :through => :squads
end</p>

<p>class Squad &lt; ActiveRecord::Base
  belongs_to :kindergarten
  has_many :students
end</p>

<p>class Student &lt; ActiveRecord::Base
  belongs_to :squad
end
```</p>

<p>这种方式适用于三层关系(祖,父,孙)的，而且在第三层不用写belongs_to第一层</p>

<h4>自关联(self join)</h4>

<p>foreign_key是可以指定你想要的任何字段,通过foreign_key我们可以实现自关联(Self Joins),即一个表中即定义了has_many又定义了belongs_to,例如<a href="http://yinsigan.github.io/blog/2013/12/09/acts-as-treeyuan-ma-fen-xi/">acts_as_tree</a>就是这样实现的,它是一个树结构,它是这样实现的</p>

<p><code>ruby comment.rb
class Comment &lt; ActiveRecord::Base
  has_many   :children, :class_name =&gt; 'Comment', :foreign_key =&gt; :parent_id
  belongs_to :parent,   :class_name =&gt; 'Comment', :foreign_key =&gt; :parent_id
end
</code></p>

<h3>一对一</h3>

<p>通过<strong>has_one</strong>或<strong>has_one :through</strong>来定义,一个<strong>modelA</strong>有一个<strong>modelB</strong>, 那么<strong>modelB</strong>属于<strong>modelA</strong>,他们之间是一对一的关系,例如一个男人只有一个妻子,一个人只有一个身份证都是现实中一对一的关系</p>

<h4>has_one</h4>

<p><img src="/images/rails_association/has_one_belongs_to.png"></p>

<p>``` ruby
class User &lt; ActiveRecord::Base
  has_one :profile
end</p>

<p>class Profile &lt; ActiveRecord::Base
  belongs_to :user
end
```</p>

<p>一对一的关系也是要通过foreign_key来关联的</p>

<h4>has_one :through</h4>

<p><img src="/images/rails_association/has_one_through.png"></p>

<p>``` ruby
class User &lt; ActiveRecord::Base
  has_one :profile
  has_one :proile_detail, :through => :profile
end</p>

<p>class Profile &lt; ActiveRecord::Base
  belongs_to :user
  has_one :proile_detail
end</p>

<p>class ProfileDetail &lt; ActiveRecord::Base
  belongs_to :profile
end
```</p>

<p>这个<strong>has_one :through</strong>的原理跟<strong>has_many :through</strong>的差不多,都是三级关系</p>

<h3>多对多</h3>

<p>能过<strong>has_many :through</strong>或<strong>has_many_and_belongs_to</strong>来定义,<strong>modelA</strong>有很多<strong>modelB</strong>,<strong>modelB</strong>也有很多<strong>modelA</strong>,它们之间是多对多的关系,例如人有很多的钱,钱属于很多人</p>

<h4>has_many :through</h4>

<p><img src="/images/rails_association/has_many_through.png"></p>

<p>``` ruby
class Staff &lt; ActiveRecord::Base
  has_many :teachers
  has_many :squads, :through => :teachers
end</p>

<p>class Squad &lt; ActiveRecord::Base
  has_many :teachers
  has_many :squads, :through => :teachers
end</p>

<p>class Teacher &lt; ActiveRecord::Base
  belongs_to :squad
  belongs_to :staff
end
```</p>

<p>多对多的实现是要通过中间表的,而has_many :through这种方式的中间表有两个好处,第一个是表名你可以自己随便命名(比较人性化),第二个好处你可以在中间表上加属性</p>

<h4>has_many_and_belongs_to</h4>

<p><img src="/images/rails_association/has_many_and_belongs_to.png"></p>

<p><code>ruby
class Role &lt; ActiveRecord::Base
  has_and_belongs_to_many :operates
end
class Operate &lt; ActiveRecord::Base
  has_and_belongs_to_many :roles
end
</code></p>

<p>这种方式对中间表的命名是有规定的,连中间表的model也不用写,<strong>has_many_and_belongs_to</strong>是rails提供的,缺点是不能灵活控制,优点是方便</p>

<p>在migration创建表不创建id(没必要)</p>

<h3>Polymorphic Associations(多态)</h3>

<p>上述都是两个表进行关联,有的不需要中间表,有的不需要,如果要实现三个表以上的关联呢,这个时候就要用到多态了,例如我们不止在文章里可以加评论,在新闻里也可以评论,在贴子里都可以</p>

<p><img src="/images/rails_association/polymorphic.png"></p>

<p>``` ruby
class Followable &lt; ActiveRecord::Base
  belongs_to :followable, :polymorphic => true
end</p>

<p>class Book &lt; ActiveRecord::Base
  has_many :follow, :as => :followable
end</p>

<p>class User &lt; ActiveRecord::Base
  has_many :follow, :as => :followable
end</p>

<p>class Comment &lt; ActiveRecord::Base
  has_many :follow, :as => :followable
end
```</p>

<p>多态的方法很灵活,它也需要一个中间表,但是他不止能关联一个表,而关联无数个表,在中间表中一个字段是存关联表的类型,一个存id,它通过这两个字段来实现关联所有表的</p>

<h3>单表继承</h3>

<p>有些模型的相似度达到百分之九十,甚至有些只有一个字段的值不同,没必要复制一遍model，再改不同的字段</p>

<p>这个时候可以用一个字段但存的值是不同的,这种方式可以的,只是因为类型不同,数据和逻辑不同,控制器即使写两套，还是要做各种判断,代码会变得很乱,很麻烦</p>

<p>这个时候一个好的解决方案就是用单表继承</p>

<p><img src="/images/rails_association/single_table_inheritance.png"></p>

<p>``` ruby
class GrowthRecord &lt; ActiveRecord::Base
end</p>

<p>class HomeGrowthRecord &lt; GrowthRecord
end</p>

<p>class GardenGrowthRecord &lt; GrowthRecord
end
```</p>

<p>GrowthRecord必须存一个字段叫type:string的,这个是自动处理的</p>

<p>如果不让GrowthRecord被实例化,可以加self.abstract_class = true,这样GrowthRecord就被锁住了</p>

<h2>总结</h2>

<p>学习这些可以让我们对rails association更理解,理解如何设计数据库,处理复杂的逻辑关系</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[acts_as_tree源码分析]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/09/acts-as-treeyuan-ma-fen-xi/"/>
    <updated>2013-12-09T14:30:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/09/acts-as-treeyuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<ul>
<li><a href="https://github.com/amerine/acts_as_tree">acts_as_tree</a></li>
</ul>


<h3>这个gem是干什么的?原理是什么?</h3>

<p>这个gem是用来实现树型结构的,例如一个分类(category),下面还有子分类,这个时候就可以用它了,还有,你回复了一个贴子,别人再来回复你，这个时候也可以用它。一个菜单之下还有子菜单，子菜单之下又可以有子菜单,子菜单之下有菜单项，它可以实现一种树型结构的菜单。它的原理也很简单,在模型中是实现了一个自关联,假如在一个comment(评论)model中,定义一个children(孩子),再定义一个parent(父), :class_name都是'Comment'。那他们怎么实现关联的,也就是说孩子要知道父亲是谁,父亲要知道它有哪些孩子,它在数据存储中是通过一个字段来关联的,在这个gem中这个字段叫<strong>parent_id</strong>假如我们创建一个根(root), <code>root = Comment.create</code>, 这个时候<strong>root</strong>*的parent_id是null,它是一个根,<code>children = root.children.create</code>,这个<strong>children</strong>是<strong>root</strong>的一个孩子,那<strong>children</strong>的<strong>parent_id</strong>就是<strong>root</strong>的<strong>id</strong></p>

<p>```
  菜单
   |<em> 系统设置
   |    |</em> 模版设置
   |    |<em> 表格设置
   |</em> 人员管理</p>

<pre><code>    |_ 教职工管理
    |_ 学员管理
</code></pre>

<p>```</p>

<p>children和parent的关系是这样实现的</p>

<p><code>ruby
belongs_to :parent...
has_many   :children...
</code></p>

<p>数据表是这样存储的</p>

<!-- more -->


<p><img src="/images/acts_as_tree_table.png"></p>

<h3>分析</h3>

<p>它的核心文件只有一个<strong>lib/acts_as_tree.rb</strong></p>

<p>``` ruby lib/acts_as_tree.rb</p>

<p>require &lsquo;acts_as_tree/version&rsquo;</p>

<p>module ActsAsTree</p>

<p>  if defined? Rails::Railtie</p>

<pre><code>require 'acts_as_tree/railtie'
</code></pre>

<p>  elsif defined? Rails::Initializer</p>

<pre><code>raise "acts_as_tree 1.0 is not compatible with Rails 2.3 or older"
</code></pre>

<p>  end</p>

<p>  def self.included(base)</p>

<pre><code>base.extend(ClassMethods)
</code></pre>

<p>  end</p>

<p>  # Specify this +acts_as+ extension if you want to model a tree structure
  # by providing a parent association and a children association. This
  # requires that you have a foreign key column, which by default is called
  # +parent_id+.
  #
  #   class Category &lt; ActiveRecord::Base
  #     include ActsAsTree
  #
  #     acts_as_tree :order => &ldquo;name&rdquo;
  #   end
  #
  #   Example:
  #   root
  #    _ child1
  #         _ subchild1
  #         _ subchild2
  #
  #   root      = Category.create(&ldquo;name&rdquo; => &ldquo;root&rdquo;)
  #   child1    = root.children.create(&ldquo;name&rdquo; => &ldquo;child1&rdquo;)
  #   subchild1 = child1.children.create(&ldquo;name&rdquo; => &ldquo;subchild1&rdquo;)
  #
  #   root.parent   # => nil
  #   child1.parent # => root
  #   root.children # => [child1]
  #   root.children.first.children.first # => subchild1
  #
  # In addition to the parent and children associations, the following
  # instance methods are added to the class after calling
  # <tt>acts_as_tree</tt>:
  # * <tt>siblings</tt> &ndash; Returns all the children of the parent, excluding
  #                       the current node (<tt>[subchild2]</tt> when called
  #                       on <tt>subchild1</tt>)
  # * <tt>self_and_siblings</tt> &ndash; Returns all the children of the parent,
  #                                including the current node (<tt>[subchild1, subchild2]</tt>
  #                                when called on <tt>subchild1</tt>)
  # * <tt>ancestors</tt> &ndash; Returns all the ancestors of the current node
  #                        (<tt>[child1, root]</tt> when called on <tt>subchild2</tt>)
  # * <tt>root</tt> &ndash; Returns the root of the current node (<tt>root</tt>
  #                   when called on <tt>subchild2</tt>)
  module ClassMethods</p>

<pre><code># Configuration options are:
#
# * &lt;tt&gt;foreign_key&lt;/tt&gt; - specifies the column name to use for tracking
#                          of the tree (default: +parent_id+)
# * &lt;tt&gt;order&lt;/tt&gt; - makes it possible to sort the children according to
#                    this SQL snippet.
# * &lt;tt&gt;counter_cache&lt;/tt&gt; - keeps a count in a +children_count+ column
#                            if set to +true+ (default: +false+).

# 是通过这个方法来明确rails model association的(has_many belongs_to),而且这个方法会导入InstanceMethods model
def acts_as_tree(options = {})

  # 默认的配置选项, dependent当你删除节点时，连同子节点全部删除
  configuration = {
    foreign_key:   "parent_id",
    order:         nil,
    counter_cache: nil,
    dependent:     :destroy
  }

  # 替换原来的方法或增加新的option
  configuration.update(options) if options.is_a?(Hash)

  # 定义一个自关联的parent, 如果设count_cache: true那就得在数据表中加入comments_count(comments是你的表名), foreign_key是parent_id，主要是通过它来关联parent和children
  belongs_to :parent, class_name:    name,
    foreign_key:   configuration[:foreign_key],
    counter_cache: configuration[:counter_cache],
    inverse_of:    :children

  # 跟上述差不多,更多的可以看rails guides associations
  if ActiveRecord::VERSION::MAJOR &gt;= 4
    has_many :children, lambda { order configuration[:order] },
      class_name:  name,
      foreign_key: configuration[:foreign_key],
      dependent:   configuration[:dependent],
      inverse_of:  :parent
  else
    has_many :children, class_name:  name,
      foreign_key: configuration[:foreign_key],
      order:       configuration[:order],
      dependent:   configuration[:dependent],
      inverse_of:  :parent
  end

  # 下面都是类的实例方法,相当于class &lt;&lt; self
  class_eval &lt;&lt;-EOV
    # 包含实例方法
    include ActsAsTree::InstanceMethods

    # update之后更新counter_cache, 关于create之后更新counter_cache是自动进行的
    after_update :update_parents_counter_cache

    # 以一个数组形式返回所有的根,可通过Comment.roots这样调用
    def self.roots
      # %Q的用法参考这里http://simpleror.wordpress.com/2009/03/15/q-q-w-w-x-r-s/
      # fetch是一个Hash的方法,对传过来的值作为key来取值,没有这个key就用第二个参数来代替
      # 在老版本的acts_as_tree中用#{configuration[:order].nil? ? "nil" : %Q{"#{configuration[:order]}"}},明显用fetch简洁好多
      order_option = %Q{#{configuration.fetch :order, "nil"}}
      # nil查询在老版本的acts_as_tree中用is NULL
      where(:#{configuration[:foreign_key]} =&gt; nil).order(order_option)
    end

    # 返回数据中的根
    def self.root
      order_option = %Q{#{configuration.fetch :order, "nil"}}
      self.roots.first
    end
  EOV
end
</code></pre>

<p>  end</p>

<p>  # extend Presentation,这个module下定义的都是类方法,用Comment.tree_view来调用
  module Presentation</p>

<pre><code># show records in a tree view
# Example:
# root
#  |_ child1
#  |    |_ subchild1
#  |    |_ subchild2
#  |_ child2
#       |_ subchild3
#       |_ subchild4
#
# 看上面的例子，用一种良好阅读的方式返回树的形状
# 树的遍历要用到递归
def tree_view(label_method = :to_s,  node = nil, level = -1)
  if node.nil?
    puts "root"
    # roots是个类方法,返回所有包含根节点的数组
    nodes = roots
  else
    label = "|_ #{node.send(label_method)}"
    if level == 0
      puts " #{label}"
    else
      puts " |#{"    "*level}#{label}"
    end
    nodes = node.children
  end
  # 1.首先默认传入node=nil, level=-1,这个时候会执行node.nil?，在第一行输出root,接着返回包含根节点的数组
  # 2.遍历由根节点组成的数组,执行tree_view递归函数,而这个时候,node不等于nil,level=0,执行level == 0下面一句输出第一个根节点(类似|_root)
  # 3.接着把这个根节点的孩子传给nodes去执行第二步, 这个node是不会等于nil的,level也将大于1,将会执行puts " |#{"    "*level}#{label}"这一行,在第二层树中level等于1,在输出时前面会空出一份空白,假如第二层树中有孩子,还会继续遍历,直到没有孩子
  nodes.each do |child|
    tree_view(label_method, child, level+1)
  end
end
</code></pre>

<p>  end</p>

<p>  # 下面定义都是实例方法
  module InstanceMethods</p>

<pre><code># Returns list of ancestors, starting from parent until root.
#
#   subchild1.ancestors # =&gt; [child1, root]
# 返回祖先链
def ancestors
  node, nodes = self, []
  nodes &lt;&lt; node = node.parent while node.parent
  nodes
end

# Returns the root node of the tree.
# 返回根节点
def root
  node = self
  node = node.parent while node.parent
  node
end

# Returns all siblings of the current node.
#
#   subchild1.siblings # =&gt; [subchild2]
# 返回所有兄弟节点
def siblings
  # 减掉自己就是兄弟节点
  self_and_siblings - [self]
end

# Returns all siblings and a reference to the current node.
#
#   subchild1.self_and_siblings # =&gt; [subchild1, subchild2]
# 返回自身加上兄弟节点
def self_and_siblings
  # 如果不是根节点就把根节点的所有孩子都返回
  # 否则的话就把所有根节点返回
  # class能引用到自身的类
  parent ? parent.children : self.class.roots
end

# Returns children (without subchildren) and current node itself.
#
#   root.self_and_children # =&gt; [root, child1]
# 返回自身和孩子
def self_and_children
  [self] + self.children
end

# Returns ancestors and current node itself.
#
#   subchild1.self_and_ancestors # =&gt; [subchild1, child1, root]
# 返回自己和祖先
def self_and_ancestors
  [self] + self.ancestors
end

# Returns true if node has no parent, false otherwise
#
#   subchild1.root? # =&gt; false
#   root.root?      # =&gt; true
# 判断是否是根节点
def root?
  parent.nil?
end

# Returns true if node has no children, false otherwise
#
#   subchild1.leaf? # =&gt; true
#   child1.leaf?    # =&gt; false
# 没有孩子了就是叶子节点
def leaf?
  children.count == 0
end

private

# 为使这个方法生效必须有:counter_cache =&gt; :children_count和children_count这个字段,不然你自己可以重写这个方法, :counter_cache是可以自定义的,默认是children的表名加cache，例如comments_cache
def update_parents_counter_cache
  # 首先用respond_to?判断是否有这个方法(:children_count)
  # 通过Active Model Dirty来判断是否改变了parent_id
  # 关于Active Model Dirty可以看http://api.rubyonrails.org/classes/ActiveModel/Dirty.html
  if self.respond_to?(:children_count) &amp;&amp; parent_id_changed?
    # decrement_counter是给:children_count减少1, parent_id_was是旧的值
    self.class.decrement_counter(:children_count, parent_id_was)
    # increment_counter是给:children_count增加1, parent_id是新的值
    # 具体的decrement_counter和increment_counter可以看http://api.rubyonrails.org/classes/ActiveRecord/CounterCache/ClassMethods.html
    self.class.increment_counter(:children_count, parent_id)
  end
end
</code></pre>

<p>  end
end</p>

<h1>Deprecating the following code in the future.</h1>

<p>require &lsquo;acts_as_tree/active_record/acts/tree&rsquo;</p>

<p>```</p>

<h3>总结</h3>

<p>通过这个gem我们可以学一些查询方法,例如关于根节点，祖先节点的查找啊,还可以学习自关联的写法,一些递归写法等</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[acts_as_follower源码分析]]></title>
    <link href="http://yinsigan.github.io/blog/2013/12/03/acts-as-followeryuan-ma-fen-xi/"/>
    <updated>2013-12-03T16:41:00+08:00</updated>
    <id>http://yinsigan.github.io/blog/2013/12/03/acts-as-followeryuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<ul>
<li><a href="https://github.com/tcocca/acts_as_follower">acts_as_follower</a></li>
</ul>


<h3>这个gem是做什么的?原理是什么?</h3>

<p>这个gem主要是用来实现类似twitter那种关注，新浪那种收听的功能
主要是两个model的关联,例如一个用户订阅了一本书,我们可以这样实现<code>User.first.follow(Book.first)</code></p>

<p>它在实现是就是利用两个多态，一个叫followable(被follow者), 一个叫followable(跟随者),把每个对象的类名字符串和id存进数据库实现关联,其他代码就实现了关于两者的查询代码, 下面是两者的关系</p>

<p><code>ruby
has_many :followings, :as =&gt; :followable, :dependent =&gt; :destroy, :class_name =&gt; 'Follow'
has_many :follows, :as =&gt; :follower, :dependent =&gt; :destroy
</code></p>

<p><code>ruby follow.rb
belongs_to :followable, :polymorphic =&gt; true
belongs_to :follower,   :polymorphic =&gt; true
</code></p>

<hr />

<h3>来看一下它的数据结构</h3>

<p>目录树结构</p>

<p><img src="/images/acts_as_follower_file_tree.png"></p>

<p>结构库表结构</p>

<p><img src="/images/acts_as_follower_table_tree.png"></p>

<p>主要有五个字段,分别是<strong>blocked</strong>, <strong>followable_id</strong>, <strong>followable_type</strong>, <strong>follower_id</strong>, <strong>follower_type</strong>, 主要是分为两个多态(<strong>follower</strong>, <strong>followerable</strong>), 例如一个用户订阅了一本书, <strong>followerable</strong>可以存<strong>Book</strong>和它的<strong>id</strong>, 而<strong>follower</strong>这个多态存<strong>User</strong>和它的<strong>id</strong></p>

<hr />

<h3>接下来就来分晰啦</h3>

<h4>源码目录结构功能介绍</h4>

<!-- more -->


<ul>
<li>lib/acts_as_follower.rb: 主文件,主要定义了ActsAsFollower这个model(每个gem都会做差不多的事),还包括一些autoload语句，做的事主要是require你的所用到的rb文件啦</li>
</ul>


<p>``` ruby lib/acts_as_follower
require &ldquo;acts_as_follower/version&rdquo;</p>

<p>module ActsAsFollower
  autoload :Follower,     &lsquo;acts_as_follower/follower&rsquo;
  autoload :Followable,   &lsquo;acts_as_follower/followable&rsquo;
  autoload :FollowerLib,  &lsquo;acts_as_follower/follower_lib&rsquo;
  autoload :FollowScopes, &lsquo;acts_as_follower/follow_scopes&rsquo;</p>

<p>  require &lsquo;acts_as_follower/railtie&rsquo; if defined?(Rails) &amp;&amp; Rails::VERSION::MAJOR >= 3
end
```</p>

<ul>
<li>lib/acts_as_follower/railtie.rb: 这个文件的作用就大了,在model(继承自<strong>ActiveRecord::Base</strong>)能使用<strong>acts_as_followable</strong>,<strong>acts_as_follower</strong>这个多亏了这个文件,其实这个文件使用了一个叫railtie的rails部件,它官方的定义是这样的:<strong>Railtie is the core of the Rails framework and provides several hooks to extend Rails and/or modify the initialization process</strong>, 它能修改一些启动信息,在加载ActiveRecord部件时执行<code>include ActsAsFollower::Follower</code>这样的语句,以后每个继承自ActiveRecord::Base的class都能使用ActsAsFollower::Follower下面定义的方法(而acts_as_follower就是在这个文件里定义的)，其实可以用类似这样的写法<code>ActiveRecord::Base.send(:include, Juixe::Acts::Commentable)</code>来实现相同的目的,关于rails railtie的详细信息可查看<a href="http://api.rubyonrails.org/classes/Rails/Railtie.html">rails railtie</a>和<a href="http://ihower.tw/blog/archives/4873">Rails3: Railtie 和 Plugins 系統</a></li>
</ul>


<p>``` ruby lib/acts_as_follower/railtie.rb
require &lsquo;acts_as_follower&rsquo;
require &lsquo;rails&rsquo;</p>

<p>module ActsAsFollower
  class Railtie &lt; Rails::Railtie</p>

<pre><code>initializer "acts_as_follower.active_record" do |app|
  ActiveSupport.on_load :active_record do
    include ActsAsFollower::Follower
    include ActsAsFollower::Followable
  end
end
</code></pre>

<p>  end
end
```</p>

<ul>
<li>lib/acts_as_follower/followable.rb: 这个文件主要服务于被follow的对象,它定义了好多用于被<strong>follow</strong>的实例方法,包括<strong>followers_by_type</strong>, <strong>followers_count</strong>,它是这样来调用的,例如<code>Book.first.followers_count</code>, <code>Book.first.followers_by_type('User')</code></li>
</ul>


<p>``` ruby lib/acts_as_follower/followable.rb</p>

<h1>被follow</h1>

<p>module ActsAsFollower #:nodoc:</p>

<p>  # 由上面可知ActiveRecord会include下面的Followable
  module Followable</p>

<pre><code># 这种写法很常见
def self.included(base)
  base.extend ClassMethods
end

# ClassMethods下面定义的是实例方法,ActiveRecord::Base可直接用，也就是说可以直接在继承自ActiveRecord::Base的model下用
module ClassMethods
  def acts_as_followable
    has_many :followings, :as =&gt; :followable, :dependent =&gt; :destroy, :class_name =&gt; 'Follow'
    # 下面的实例方法
    include ActsAsFollower::Followable::InstanceMethods
    # 这个下文有说
    include ActsAsFollower::FollowerLib
  end
end

# 下面的都是实例方法可用于被follow的实例来调用,下面的self都是被follow对象的实例
module InstanceMethods

  # Returns the number of followers a record has.
  # 返回followins的数量,而unblocked在lib/acts_as_followable/follow_scope.rb定义,只是一个简单的where scope
  def followers_count
    self.followings.unblocked.count
  end

  # Returns the followers by a given type
  # 下面主要是一个查询语句,constantize的定义见http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html
  # 而parent_class_name的定义在lib/acts_as_followable/follower_lib.rb,很简单,主要是返回class名字
  def followers_by_type(follower_type, options={})
    # parent_class_name是把一个实例转成类的字符串,例如'Topic', 'Article'等
    follows = follower_type.constantize.
      joins(:follows).
      where('follows.blocked'         =&gt; false,
            'follows.followable_id'   =&gt; self.id,
            'follows.followable_type' =&gt; parent_class_name(self),
            'follows.follower_type'   =&gt; follower_type)
    if options.has_key?(:limit)
      follows = follows.limit(options[:limit])
    end
    if options.has_key?(:includes)
      follows = follows.includes(options[:includes])
    end
    follows
  end

  # 返回所有follower的数量
  def followers_by_type_count(follower_type)
    self.followings.unblocked.for_follower_type(follower_type).count
  end

  # Allows magic names on followers_by_type
  # e.g. user_followers == followers_by_type('User')
  # Allows magic names on followers_by_type_count
  # e.g. count_user_followers == followers_by_type_count('User')
  # 实现更加灵活的查询
  def method_missing(m, *args)
    if m.to_s[/count_(.+)_followers/]
      followers_by_type_count($1.singularize.classify)
    elsif m.to_s[/(.+)_followers/]
      followers_by_type($1.singularize.classify)
    else
      super
    end
  end

  # 返回follow的数量
  def blocked_followers_count
    self.followings.blocked.count
  end

  # Returns the followings records scoped
  def followers_scoped
    # 因为follow belongs_to follower
    self.followings.includes(:follower)
  end

  # apply_options_to_scope是定义在lib/acts_as_followable/follower_lib.rb的一个方法,只要是过滤参数,把参数提取加到where scope中
  # 返回所有followers
  def followers(options={})
    followers_scope = followers_scoped.unblocked
    followers_scope = apply_options_to_scope(followers_scope, options)
    # 取出所有follower
    followers_scope.to_a.collect{|f| f.follower}
  end

  def blocks(options={})
    blocked_followers_scope = followers_scoped.blocked
    blocked_followers_scope = apply_options_to_scope(blocked_followers_scope, options)
    blocked_followers_scope.to_a.collect{|f| f.follower}
  end

  # Returns true if the current instance is followed by the passed record
  # Returns false if the current instance is blocked by the passed record or no follow is found
  # 查看是否被follow
  def followed_by?(follower)
    self.followings.unblocked.for_follower(follower).first.present?
  end

  # 如果查到记录就变成true，没有就创建那条记录
  def block(follower)
    get_follow_for(follower) ? block_existing_follow(follower) : block_future_follow(follower)
  end

  # 把following的记录删除
  def unblock(follower)
    get_follow_for(follower).try(:delete)
  end

  # 返回是否被follower, for_follower是个where scope
  def get_follow_for(follower)
    self.followings.for_follower(follower).first
  end

  private

  # 创建following记录
  def block_future_follow(follower)
    Follow.create(:followable =&gt; self, :follower =&gt; follower, :blocked =&gt; true)
  end

  # block!会把blocked属性变成true
  def block_existing_follow(follower)
    get_follow_for(follower).block!
  end

end
</code></pre>

<p>  end
end</p>

<p>```</p>

<ul>
<li>lib/acts_as_follower/follower.rb: 这是一个关于<strong>follower</strong>(叫做跟随者), 跟<strong>followable.rb</strong>的作用差不多，只是是反过来的</li>
</ul>


<p>``` ruby lib/acts_as_follower/follower.rb
module ActsAsFollower #:nodoc:
  module Follower</p>

<pre><code># active_record会include
def self.included(base)
  base.extend ClassMethods
end

module ClassMethods
  # 在model里就可以用acts_as_follower
  def acts_as_follower
    has_many :follows, :as =&gt; :follower, :dependent =&gt; :destroy
    # 具体类加载实例方法
    include ActsAsFollower::Follower::InstanceMethods
    # 具体类加载FollowerLib库方法
    include ActsAsFollower::FollowerLib
  end
end

module InstanceMethods

  # Returns true if this instance is following the object passed as an argument.
  # 是否following某个followable
  def following?(followable)
    0 &lt; Follow.unblocked.for_follower(self).for_followable(followable).count
  end

  # Returns the number of objects this instance is following.
  # 在数据表中查看这个follower总共跟随了多少followable
  def follow_count
    Follow.unblocked.for_follower(self).count
  end

  # Creates a new follow record for this instance to follow the passed object.
  # Does not allow duplicate records to be created.
  # follow某followable
  def follow(followable)
    if self != followable
      self.follows.find_or_create_by(followable_id: followable.id, followable_type: parent_class_name(followable))
    end
  end

  # Deletes the follow record if it exists.
  def stop_following(followable)
    # get_follow是用followable来找到那条follow记录然后把它删除掉
    if follow = get_follow(followable)
      follow.destroy
    end
  end

  # returns the follows records to the current instance
  def follows_scoped
    self.follows.unblocked.includes(:followable)
  end

  # Returns the follow records related to this instance by type.
  def follows_by_type(followable_type, options={})
    follows_scope  = follows_scoped.for_followable_type(followable_type)
    follows_scope = apply_options_to_scope(follows_scope, options)
  end

  # Returns the follow records related to this instance with the followable included.
  def all_follows(options={})
    follows_scope = follows_scoped
    follows_scope = apply_options_to_scope(follows_scope, options)
  end

  # Returns the actual records which this instance is following.
  def all_following(options={})
    all_follows(options).collect{ |f| f.followable }
  end

  # Returns the actual records of a particular type which this record is following.
  def following_by_type(followable_type, options={})
    followables = followable_type.constantize.
      joins(:followings).
      where('follows.blocked'         =&gt; false,
            'follows.follower_id'     =&gt; self.id,
            'follows.follower_type'   =&gt; parent_class_name(self),
            'follows.followable_type' =&gt; followable_type)
    if options.has_key?(:limit)
      followables = followables.limit(options[:limit])
    end
    if options.has_key?(:includes)
      followables = followables.includes(options[:includes])
    end
    followables
  end

  def following_by_type_count(followable_type)
    follows.unblocked.for_followable_type(followable_type).count
  end

  # Allows magic names on following_by_type
  # e.g. following_users == following_by_type('User')
  # Allows magic names on following_by_type_count
  # e.g. following_users_count == following_by_type_count('User')
  def method_missing(m, *args)
    if m.to_s[/following_(.+)_count/]
      following_by_type_count($1.singularize.classify)
    elsif m.to_s[/following_(.+)/]
      following_by_type($1.singularize.classify)
    else
      super
    end
  end

  # Returns a follow record for the current instance and followable object.
  def get_follow(followable)
    self.follows.unblocked.for_followable(followable).first
  end

end
</code></pre>

<p>  end
end</p>

<p><code>``
+ lib/acts_as_follower/follow_scopes.rb: 这里封装的都是一些查询语句,在**follow.rb**文件里有一句</code>extend ActsAsFollower::FollowScopes`可以在实例上使用这些方法</p>

<p>``` ruby lib/acts_as_follower/follow_scopes.rb
module ActsAsFollower #:nodoc:
  module FollowScopes</p>

<pre><code>def for_follower(follower)
  where(:follower_id =&gt; follower.id,
        :follower_type =&gt; parent_class_name(follower))
end

def for_followable(followable)
  where(:followable_id =&gt; followable.id, :followable_type =&gt; parent_class_name(followable))
end

def for_follower_type(follower_type)
  where(:follower_type =&gt; follower_type)
end

def for_followable_type(followable_type)
  where(:followable_type =&gt; followable_type)
end

def recent(from)
  where(["created_at &gt; ?", (from || 2.weeks.ago).to_s(:db)])
end

def descending
  order("follows.created_at DESC")
end

def unblocked
  where(:blocked =&gt; false)
end

def blocked
  where(:blocked =&gt; true)
end
</code></pre>

<p>  end
end
```</p>

<ul>
<li>lib/acts_as_follower/follower_lib.rb: 这里封装了两个方法,上文有讲过,<strong>follow.rb</strong>文件里有一句<code>extend ActsAsFollower::FollowerLib</code></li>
</ul>


<p>``` ruby lib/acts_as_follower/follower_lib.rb
module ActsAsFollower
  module FollowerLib</p>

<pre><code>private

# Retrieves the parent class name if using STI.
def parent_class_name(obj)
  if obj.class.superclass != ActiveRecord::Base
    return obj.class.superclass.name
  end
  return obj.class.name
end

def apply_options_to_scope(scope, options = {})
  if options.has_key?(:limit)
    scope = scope.limit(options[:limit])
  end
  if options.has_key?(:includes)
    scope = scope.includes(options[:includes])
  end
  if options.has_key?(:joins)
    scope = scope.joins(options[:joins])
  end
  if options.has_key?(:where)
    scope = scope.order(options[:where])
  end
  if options.has_key?(:order)
    scope = scope.order(options[:order])
  end
  scope
end
</code></pre>

<p>  end
end</p>

<p>```</p>

<ul>
<li>lib/acts_as_follower/generators/templates/follow.rb: 这个文件是用来生成模版的,生成的是一个model文件,放在app/models下,它是一个中间表,是所有<strong>follower</strong>和<strong>followable</strong>的链接点</li>
</ul>


<p>``` ruby app/models/follow.rb
class Follow &lt; ActiveRecord::Base</p>

<p>  extend ActsAsFollower::FollowerLib
  extend ActsAsFollower::FollowScopes</p>

<p>  # NOTE: Follows belong to the &ldquo;followable&rdquo; interface, and also to followers
  belongs_to :followable, :polymorphic => true
  belongs_to :follower,   :polymorphic => true</p>

<p>  def block!</p>

<pre><code>self.update_attribute(:blocked, true)
</code></pre>

<p>  end</p>

<p>end
```</p>

<h3>总结</h3>

<p>学会组织代码的能力和一些rails的内部的东西,学习这个gem查询一些数据的方法,还有双重多态的写法</p>
]]></content>
  </entry>
  
</feed>
